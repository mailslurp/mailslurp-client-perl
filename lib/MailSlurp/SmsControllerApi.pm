=begin comment

MailSlurp API

MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository

The version of the OpenAPI document: 6.5.2
Contact: contact@mailslurp.dev
Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
package MailSlurp::SmsControllerApi;

require 5.6.0;
use strict;
use warnings;
use utf8; 
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use MailSlurp::ApiClient;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class = shift;
    my $api_client;

    if ($_[0] && ref $_[0] && ref $_[0] eq 'MailSlurp::ApiClient' ) {
        $api_client = $_[0];
    } else {
        $api_client = MailSlurp::ApiClient->new(@_);
    }

    bless { api_client => $api_client }, $class;

}


#
# delete_sms_message
#
# Delete SMS message.
# 
# @param string $sms_id  (required)
{
    my $params = {
    'sms_id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_sms_message' } = { 
        summary => 'Delete SMS message.',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub delete_sms_message {
    my ($self, %args) = @_;

    # verify the required parameter 'sms_id' is set
    unless (exists $args{'sms_id'}) {
      croak("Missing the required parameter 'sms_id' when calling delete_sms_message");
    }

    # parse inputs
    my $_resource_path = '/sms/{smsId}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'sms_id'}) {
        my $_base_variable = "{" . "smsId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'sms_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# delete_sms_messages
#
# Delete all SMS messages
# 
# @param string $phone_number_id  (optional)
{
    my $params = {
    'phone_number_id' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_sms_messages' } = { 
        summary => 'Delete all SMS messages',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub delete_sms_messages {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/sms';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'phone_number_id'}) {
        $query_params->{'phoneNumberId'} = $self->{api_client}->to_query_value($args{'phone_number_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# get_reply_for_sms_message
#
# Get reply for an SMS message
# 
# @param string $sms_id  (required)
{
    my $params = {
    'sms_id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_reply_for_sms_message' } = { 
        summary => 'Get reply for an SMS message',
        params => $params,
        returns => 'ReplyForSms',
        };
}
# @return ReplyForSms
#
sub get_reply_for_sms_message {
    my ($self, %args) = @_;

    # verify the required parameter 'sms_id' is set
    unless (exists $args{'sms_id'}) {
      croak("Missing the required parameter 'sms_id' when calling get_reply_for_sms_message");
    }

    # parse inputs
    my $_resource_path = '/sms/{smsId}/reply';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'sms_id'}) {
        my $_base_variable = "{" . "smsId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'sms_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ReplyForSms', $response);
    return $_response_object;
}

#
# get_sms_count
#
# Get SMS count
# 
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'get_sms_count' } = { 
        summary => 'Get SMS count',
        params => $params,
        returns => 'CountDto',
        };
}
# @return CountDto
#
sub get_sms_count {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/sms/count';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CountDto', $response);
    return $_response_object;
}

#
# get_sms_message
#
# Get SMS content including body. Expects SMS to exist by ID. For SMS that may not have arrived yet use the WaitForController.
# 
# @param string $sms_id  (required)
{
    my $params = {
    'sms_id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_sms_message' } = { 
        summary => 'Get SMS content including body. Expects SMS to exist by ID. For SMS that may not have arrived yet use the WaitForController.',
        params => $params,
        returns => 'SmsDto',
        };
}
# @return SmsDto
#
sub get_sms_message {
    my ($self, %args) = @_;

    # verify the required parameter 'sms_id' is set
    unless (exists $args{'sms_id'}) {
      croak("Missing the required parameter 'sms_id' when calling get_sms_message");
    }

    # parse inputs
    my $_resource_path = '/sms/{smsId}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'sms_id'}) {
        my $_base_variable = "{" . "smsId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'sms_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('SmsDto', $response);
    return $_response_object;
}

#
# get_sms_messages_paginated
#
# Get all SMS messages in all phone numbers in paginated form. .
# 
# @param string $phone_number Optional receiving phone number to filter SMS messages for (optional)
# @param int $page Optional page index in SMS list pagination (optional, default to 0)
# @param int $size Optional page size in SMS list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)
# @param string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
# @param boolean $unread_only Optional filter for unread SMS only. All SMS are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)
# @param DateTime $since Optional filter SMSs received after given date time (optional)
# @param DateTime $before Optional filter SMSs received before given date time (optional)
{
    my $params = {
    'phone_number' => {
        data_type => 'string',
        description => 'Optional receiving phone number to filter SMS messages for',
        required => '0',
    },
    'page' => {
        data_type => 'int',
        description => 'Optional page index in SMS list pagination',
        required => '0',
    },
    'size' => {
        data_type => 'int',
        description => 'Optional page size in SMS list pagination. Maximum size is 100. Use page index and sort to page through larger results',
        required => '0',
    },
    'sort' => {
        data_type => 'string',
        description => 'Optional createdAt sort direction ASC or DESC',
        required => '0',
    },
    'unread_only' => {
        data_type => 'boolean',
        description => 'Optional filter for unread SMS only. All SMS are considered unread until they are viewed in the dashboard or requested directly',
        required => '0',
    },
    'since' => {
        data_type => 'DateTime',
        description => 'Optional filter SMSs received after given date time',
        required => '0',
    },
    'before' => {
        data_type => 'DateTime',
        description => 'Optional filter SMSs received before given date time',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_sms_messages_paginated' } = { 
        summary => 'Get all SMS messages in all phone numbers in paginated form. .',
        params => $params,
        returns => 'PageSmsProjection',
        };
}
# @return PageSmsProjection
#
sub get_sms_messages_paginated {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/sms';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'phone_number'}) {
        $query_params->{'phoneNumber'} = $self->{api_client}->to_query_value($args{'phone_number'});
    }

    # query params
    if ( exists $args{'page'}) {
        $query_params->{'page'} = $self->{api_client}->to_query_value($args{'page'});
    }

    # query params
    if ( exists $args{'size'}) {
        $query_params->{'size'} = $self->{api_client}->to_query_value($args{'size'});
    }

    # query params
    if ( exists $args{'sort'}) {
        $query_params->{'sort'} = $self->{api_client}->to_query_value($args{'sort'});
    }

    # query params
    if ( exists $args{'unread_only'}) {
        $query_params->{'unreadOnly'} = $self->{api_client}->to_query_value($args{'unread_only'});
    }

    # query params
    if ( exists $args{'since'}) {
        $query_params->{'since'} = $self->{api_client}->to_query_value($args{'since'});
    }

    # query params
    if ( exists $args{'before'}) {
        $query_params->{'before'} = $self->{api_client}->to_query_value($args{'before'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('PageSmsProjection', $response);
    return $_response_object;
}

#
# get_unread_sms_count
#
# Get unread SMS count
# 
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'get_unread_sms_count' } = { 
        summary => 'Get unread SMS count',
        params => $params,
        returns => 'UnreadCount',
        };
}
# @return UnreadCount
#
sub get_unread_sms_count {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/sms/unreadCount';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('UnreadCount', $response);
    return $_response_object;
}

#
# reply_to_sms_message
#
# Send a reply to a received SMS message. Replies are sent from the receiving number.
# 
# @param string $sms_id  (required)
# @param SmsReplyOptions $sms_reply_options  (required)
{
    my $params = {
    'sms_id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'sms_reply_options' => {
        data_type => 'SmsReplyOptions',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'reply_to_sms_message' } = { 
        summary => 'Send a reply to a received SMS message. Replies are sent from the receiving number.',
        params => $params,
        returns => 'SentSmsDto',
        };
}
# @return SentSmsDto
#
sub reply_to_sms_message {
    my ($self, %args) = @_;

    # verify the required parameter 'sms_id' is set
    unless (exists $args{'sms_id'}) {
      croak("Missing the required parameter 'sms_id' when calling reply_to_sms_message");
    }

    # verify the required parameter 'sms_reply_options' is set
    unless (exists $args{'sms_reply_options'}) {
      croak("Missing the required parameter 'sms_reply_options' when calling reply_to_sms_message");
    }

    # parse inputs
    my $_resource_path = '/sms/{smsId}/reply';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # path params
    if ( exists $args{'sms_id'}) {
        my $_base_variable = "{" . "smsId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'sms_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'sms_reply_options'}) {
        $_body_data = $args{'sms_reply_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('SentSmsDto', $response);
    return $_response_object;
}

1;
