=begin comment

MailSlurp API

MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository

The version of the OpenAPI document: 6.5.2
Contact: contact@mailslurp.dev
Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
package MailSlurp::EmailControllerApi;

require 5.6.0;
use strict;
use warnings;
use utf8; 
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use MailSlurp::ApiClient;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class = shift;
    my $api_client;

    if ($_[0] && ref $_[0] && ref $_[0] eq 'MailSlurp::ApiClient' ) {
        $api_client = $_[0];
    } else {
        $api_client = MailSlurp::ApiClient->new(@_);
    }

    bless { api_client => $api_client }, $class;

}


#
# apply_imap_flag_operation
#
# Set IMAP flags associated with a message. Only supports '\\Seen' flag.
# 
# @param string $email_id  (required)
# @param ImapFlagOperationOptions $imap_flag_operation_options  (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'imap_flag_operation_options' => {
        data_type => 'ImapFlagOperationOptions',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'apply_imap_flag_operation' } = { 
        summary => 'Set IMAP flags associated with a message. Only supports &#39;\\Seen&#39; flag.',
        params => $params,
        returns => 'EmailPreview',
        };
}
# @return EmailPreview
#
sub apply_imap_flag_operation {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling apply_imap_flag_operation");
    }

    # verify the required parameter 'imap_flag_operation_options' is set
    unless (exists $args{'imap_flag_operation_options'}) {
      croak("Missing the required parameter 'imap_flag_operation_options' when calling apply_imap_flag_operation");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/imap-flag-operation';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'imap_flag_operation_options'}) {
        $_body_data = $args{'imap_flag_operation_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('EmailPreview', $response);
    return $_response_object;
}

#
# can_send
#
# Check if email can be sent and options are valid.
# 
# @param string $inbox_id ID of the inbox you want to send the email from (required)
# @param SendEmailOptions $send_email_options  (required)
{
    my $params = {
    'inbox_id' => {
        data_type => 'string',
        description => 'ID of the inbox you want to send the email from',
        required => '1',
    },
    'send_email_options' => {
        data_type => 'SendEmailOptions',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'can_send' } = { 
        summary => 'Check if email can be sent and options are valid.',
        params => $params,
        returns => 'CanSendEmailResults',
        };
}
# @return CanSendEmailResults
#
sub can_send {
    my ($self, %args) = @_;

    # verify the required parameter 'inbox_id' is set
    unless (exists $args{'inbox_id'}) {
      croak("Missing the required parameter 'inbox_id' when calling can_send");
    }

    # verify the required parameter 'send_email_options' is set
    unless (exists $args{'send_email_options'}) {
      croak("Missing the required parameter 'send_email_options' when calling can_send");
    }

    # parse inputs
    my $_resource_path = '/emails/can-send';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # query params
    if ( exists $args{'inbox_id'}) {
        $query_params->{'inboxId'} = $self->{api_client}->to_query_value($args{'inbox_id'});
    }

    my $_body_data;
    # body params
    if ( exists $args{'send_email_options'}) {
        $_body_data = $args{'send_email_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CanSendEmailResults', $response);
    return $_response_object;
}

#
# check_email_body_feature_support
#
# Show which mail clients support the HTML and CSS features used in an email body.
# 
# @param string $email_id  (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'check_email_body_feature_support' } = { 
        summary => 'Show which mail clients support the HTML and CSS features used in an email body.',
        params => $params,
        returns => 'CheckEmailBodyFeatureSupportResults',
        };
}
# @return CheckEmailBodyFeatureSupportResults
#
sub check_email_body_feature_support {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling check_email_body_feature_support");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/check-email-body-feature-support';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CheckEmailBodyFeatureSupportResults', $response);
    return $_response_object;
}

#
# check_email_client_support
#
# Show which email programs and devices support the features used in an email body.
# 
# @param CheckEmailClientSupportOptions $check_email_client_support_options  (required)
{
    my $params = {
    'check_email_client_support_options' => {
        data_type => 'CheckEmailClientSupportOptions',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'check_email_client_support' } = { 
        summary => 'Show which email programs and devices support the features used in an email body.',
        params => $params,
        returns => 'CheckEmailClientSupportResults',
        };
}
# @return CheckEmailClientSupportResults
#
sub check_email_client_support {
    my ($self, %args) = @_;

    # verify the required parameter 'check_email_client_support_options' is set
    unless (exists $args{'check_email_client_support_options'}) {
      croak("Missing the required parameter 'check_email_client_support_options' when calling check_email_client_support");
    }

    # parse inputs
    my $_resource_path = '/emails/check-email-client-support';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'check_email_client_support_options'}) {
        $_body_data = $args{'check_email_client_support_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CheckEmailClientSupportResults', $response);
    return $_response_object;
}

#
# delete_all_emails
#
# Delete all emails in all inboxes.
# 
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'delete_all_emails' } = { 
        summary => 'Delete all emails in all inboxes.',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub delete_all_emails {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/emails';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# delete_email
#
# Delete an email
# 
# @param string $email_id ID of email to delete (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email to delete',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_email' } = { 
        summary => 'Delete an email',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub delete_email {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling delete_email");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# download_attachment
#
# Get email attachment bytes. Returned as `octet-stream` with content type header. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints and convert the base 64 encoded content to a file or string.
# 
# @param string $email_id ID of email (required)
# @param string $attachment_id ID of attachment (required)
# @param string $api_key Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly. (optional)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email',
        required => '1',
    },
    'attachment_id' => {
        data_type => 'string',
        description => 'ID of attachment',
        required => '1',
    },
    'api_key' => {
        data_type => 'string',
        description => 'Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'download_attachment' } = { 
        summary => 'Get email attachment bytes. Returned as &#x60;octet-stream&#x60; with content type header. If you have trouble with byte responses try the &#x60;downloadAttachmentBase64&#x60; response endpoints and convert the base 64 encoded content to a file or string.',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub download_attachment {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling download_attachment");
    }

    # verify the required parameter 'attachment_id' is set
    unless (exists $args{'attachment_id'}) {
      croak("Missing the required parameter 'attachment_id' when calling download_attachment");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/attachments/{attachmentId}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/octet-stream');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'api_key'}) {
        $query_params->{'apiKey'} = $self->{api_client}->to_query_value($args{'api_key'});
    }

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'attachment_id'}) {
        my $_base_variable = "{" . "attachmentId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'attachment_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# download_attachment_base64
#
# Get email attachment as base64 encoded string as an alternative to binary responses. Decode the `base64FileContents` as a `utf-8` encoded string or array of bytes depending on the `contentType`.
# 
# @param string $email_id ID of email (required)
# @param string $attachment_id ID of attachment (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email',
        required => '1',
    },
    'attachment_id' => {
        data_type => 'string',
        description => 'ID of attachment',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'download_attachment_base64' } = { 
        summary => 'Get email attachment as base64 encoded string as an alternative to binary responses. Decode the &#x60;base64FileContents&#x60; as a &#x60;utf-8&#x60; encoded string or array of bytes depending on the &#x60;contentType&#x60;.',
        params => $params,
        returns => 'DownloadAttachmentDto',
        };
}
# @return DownloadAttachmentDto
#
sub download_attachment_base64 {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling download_attachment_base64");
    }

    # verify the required parameter 'attachment_id' is set
    unless (exists $args{'attachment_id'}) {
      croak("Missing the required parameter 'attachment_id' when calling download_attachment_base64");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/attachments/{attachmentId}/base64';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'attachment_id'}) {
        my $_base_variable = "{" . "attachmentId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'attachment_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('DownloadAttachmentDto', $response);
    return $_response_object;
}

#
# download_body
#
# Get email body as string. Returned as `plain/text` with content type header.
# 
# @param string $email_id ID of email (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'download_body' } = { 
        summary => 'Get email body as string. Returned as &#x60;plain/text&#x60; with content type header.',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub download_body {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling download_body");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/body';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain', 'text/html');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# download_body_bytes
#
# Get email body in bytes. Returned as `octet-stream` with content type header.
# 
# @param string $email_id ID of email (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'download_body_bytes' } = { 
        summary => 'Get email body in bytes. Returned as &#x60;octet-stream&#x60; with content type header.',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub download_body_bytes {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling download_body_bytes");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/body-bytes';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/octet-stream');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# forward_email
#
# Forward email to recipients
# 
# @param string $email_id ID of email (required)
# @param ForwardEmailOptions $forward_email_options  (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email',
        required => '1',
    },
    'forward_email_options' => {
        data_type => 'ForwardEmailOptions',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'forward_email' } = { 
        summary => 'Forward email to recipients',
        params => $params,
        returns => 'SentEmailDto',
        };
}
# @return SentEmailDto
#
sub forward_email {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling forward_email");
    }

    # verify the required parameter 'forward_email_options' is set
    unless (exists $args{'forward_email_options'}) {
      croak("Missing the required parameter 'forward_email_options' when calling forward_email");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/forward';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'forward_email_options'}) {
        $_body_data = $args{'forward_email_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('SentEmailDto', $response);
    return $_response_object;
}

#
# get_attachment_meta_data
#
# Get email attachment metadata. This is the `contentType` and `contentLength` of an attachment. To get the individual attachments  use the `downloadAttachment` methods.
# 
# @param string $email_id ID of email (required)
# @param string $attachment_id ID of attachment (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email',
        required => '1',
    },
    'attachment_id' => {
        data_type => 'string',
        description => 'ID of attachment',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_attachment_meta_data' } = { 
        summary => 'Get email attachment metadata. This is the &#x60;contentType&#x60; and &#x60;contentLength&#x60; of an attachment. To get the individual attachments  use the &#x60;downloadAttachment&#x60; methods.',
        params => $params,
        returns => 'AttachmentMetaData',
        };
}
# @return AttachmentMetaData
#
sub get_attachment_meta_data {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling get_attachment_meta_data");
    }

    # verify the required parameter 'attachment_id' is set
    unless (exists $args{'attachment_id'}) {
      croak("Missing the required parameter 'attachment_id' when calling get_attachment_meta_data");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/attachments/{attachmentId}/metadata';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'attachment_id'}) {
        my $_base_variable = "{" . "attachmentId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'attachment_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AttachmentMetaData', $response);
    return $_response_object;
}

#
# get_email
#
# Get email content including headers and body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController.
# 
# @param string $email_id  (required)
# @param boolean $decode Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing (optional, default to false)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'decode' => {
        data_type => 'boolean',
        description => 'Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_email' } = { 
        summary => 'Get email content including headers and body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController.',
        params => $params,
        returns => 'Email',
        };
}
# @return Email
#
sub get_email {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling get_email");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'decode'}) {
        $query_params->{'decode'} = $self->{api_client}->to_query_value($args{'decode'});
    }

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('Email', $response);
    return $_response_object;
}

#
# get_email_attachments
#
# Get all email attachment metadata. Metadata includes name and size of attachments.
# 
# @param string $email_id ID of email (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_email_attachments' } = { 
        summary => 'Get all email attachment metadata. Metadata includes name and size of attachments.',
        params => $params,
        returns => 'ARRAY[AttachmentMetaData]',
        };
}
# @return ARRAY[AttachmentMetaData]
#
sub get_email_attachments {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling get_email_attachments");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/attachments';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[AttachmentMetaData]', $response);
    return $_response_object;
}

#
# get_email_content_match
#
# Get email content regex pattern match results. Runs regex against email body and returns match groups.
# 
# @param string $email_id ID of email to match against (required)
# @param ContentMatchOptions $content_match_options  (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email to match against',
        required => '1',
    },
    'content_match_options' => {
        data_type => 'ContentMatchOptions',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_email_content_match' } = { 
        summary => 'Get email content regex pattern match results. Runs regex against email body and returns match groups.',
        params => $params,
        returns => 'EmailContentMatchResult',
        };
}
# @return EmailContentMatchResult
#
sub get_email_content_match {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling get_email_content_match");
    }

    # verify the required parameter 'content_match_options' is set
    unless (exists $args{'content_match_options'}) {
      croak("Missing the required parameter 'content_match_options' when calling get_email_content_match");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/contentMatch';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'content_match_options'}) {
        $_body_data = $args{'content_match_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('EmailContentMatchResult', $response);
    return $_response_object;
}

#
# get_email_content_part
#
# Get email content part by content type
# 
# @param string $email_id ID of email to match against (required)
# @param string $content_type Content type (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email to match against',
        required => '1',
    },
    'content_type' => {
        data_type => 'string',
        description => 'Content type',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_email_content_part' } = { 
        summary => 'Get email content part by content type',
        params => $params,
        returns => 'EmailContentPartResult',
        };
}
# @return EmailContentPartResult
#
sub get_email_content_part {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling get_email_content_part");
    }

    # verify the required parameter 'content_type' is set
    unless (exists $args{'content_type'}) {
      croak("Missing the required parameter 'content_type' when calling get_email_content_part");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/contentPart';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'content_type'}) {
        $query_params->{'contentType'} = $self->{api_client}->to_query_value($args{'content_type'});
    }

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('EmailContentPartResult', $response);
    return $_response_object;
}

#
# get_email_count
#
# Get email count
# 
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'get_email_count' } = { 
        summary => 'Get email count',
        params => $params,
        returns => 'CountDto',
        };
}
# @return CountDto
#
sub get_email_count {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/emails/emails/count';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CountDto', $response);
    return $_response_object;
}

#
# get_email_html
#
# Get email content as HTML. For displaying emails in browser context.
# 
# @param string $email_id  (required)
# @param boolean $decode  (optional, default to false)
# @param boolean $replace_cid_images  (optional, default to false)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'decode' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'replace_cid_images' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_email_html' } = { 
        summary => 'Get email content as HTML. For displaying emails in browser context.',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub get_email_html {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling get_email_html");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/html';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/html;charset=utf-8', 'text/html');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'decode'}) {
        $query_params->{'decode'} = $self->{api_client}->to_query_value($args{'decode'});
    }

    # query params
    if ( exists $args{'replace_cid_images'}) {
        $query_params->{'replaceCidImages'} = $self->{api_client}->to_query_value($args{'replace_cid_images'});
    }

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# get_email_html_json
#
# Get email content as HTML in JSON wrapper. For fetching entity decoded HTML content
# 
# @param string $email_id  (required)
# @param boolean $decode  (optional, default to false)
# @param boolean $replace_cid_images  (optional, default to false)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'decode' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    'replace_cid_images' => {
        data_type => 'boolean',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_email_html_json' } = { 
        summary => 'Get email content as HTML in JSON wrapper. For fetching entity decoded HTML content',
        params => $params,
        returns => 'EmailHtmlDto',
        };
}
# @return EmailHtmlDto
#
sub get_email_html_json {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling get_email_html_json");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/html/json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'decode'}) {
        $query_params->{'decode'} = $self->{api_client}->to_query_value($args{'decode'});
    }

    # query params
    if ( exists $args{'replace_cid_images'}) {
        $query_params->{'replaceCidImages'} = $self->{api_client}->to_query_value($args{'replace_cid_images'});
    }

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('EmailHtmlDto', $response);
    return $_response_object;
}

#
# get_email_html_query
#
# Parse and return text from an email, stripping HTML and decoding encoded characters
# 
# @param string $email_id ID of email to perform HTML query on (required)
# @param string $html_selector HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information. (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email to perform HTML query on',
        required => '1',
    },
    'html_selector' => {
        data_type => 'string',
        description => 'HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information.',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_email_html_query' } = { 
        summary => 'Parse and return text from an email, stripping HTML and decoding encoded characters',
        params => $params,
        returns => 'EmailTextLinesResult',
        };
}
# @return EmailTextLinesResult
#
sub get_email_html_query {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling get_email_html_query");
    }

    # verify the required parameter 'html_selector' is set
    unless (exists $args{'html_selector'}) {
      croak("Missing the required parameter 'html_selector' when calling get_email_html_query");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/htmlQuery';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'html_selector'}) {
        $query_params->{'htmlSelector'} = $self->{api_client}->to_query_value($args{'html_selector'});
    }

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('EmailTextLinesResult', $response);
    return $_response_object;
}

#
# get_email_links
#
# Parse and return list of links found in an email (only works for HTML content)
# 
# @param string $email_id ID of email to fetch text for (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email to fetch text for',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_email_links' } = { 
        summary => 'Parse and return list of links found in an email (only works for HTML content)',
        params => $params,
        returns => 'EmailLinksResult',
        };
}
# @return EmailLinksResult
#
sub get_email_links {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling get_email_links");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/links';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('EmailLinksResult', $response);
    return $_response_object;
}

#
# get_email_preview_ur_ls
#
# Get email URLs for viewing in browser or downloading
# 
# @param string $email_id  (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_email_preview_ur_ls' } = { 
        summary => 'Get email URLs for viewing in browser or downloading',
        params => $params,
        returns => 'EmailPreviewUrls',
        };
}
# @return EmailPreviewUrls
#
sub get_email_preview_ur_ls {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling get_email_preview_ur_ls");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/urls';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('EmailPreviewUrls', $response);
    return $_response_object;
}

#
# get_email_text_lines
#
# Parse and return text from an email, stripping HTML and decoding encoded characters
# 
# @param string $email_id ID of email to fetch text for (required)
# @param boolean $decode_html_entities Decode HTML entities (optional)
# @param string $line_separator Line separator character (optional)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email to fetch text for',
        required => '1',
    },
    'decode_html_entities' => {
        data_type => 'boolean',
        description => 'Decode HTML entities',
        required => '0',
    },
    'line_separator' => {
        data_type => 'string',
        description => 'Line separator character',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_email_text_lines' } = { 
        summary => 'Parse and return text from an email, stripping HTML and decoding encoded characters',
        params => $params,
        returns => 'EmailTextLinesResult',
        };
}
# @return EmailTextLinesResult
#
sub get_email_text_lines {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling get_email_text_lines");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/textLines';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'decode_html_entities'}) {
        $query_params->{'decodeHtmlEntities'} = $self->{api_client}->to_query_value($args{'decode_html_entities'});
    }

    # query params
    if ( exists $args{'line_separator'}) {
        $query_params->{'lineSeparator'} = $self->{api_client}->to_query_value($args{'line_separator'});
    }

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('EmailTextLinesResult', $response);
    return $_response_object;
}

#
# get_emails_offset_paginated
#
# Get all emails in all inboxes in paginated form. Email API list all.
# 
# @param ARRAY[string] $inbox_id Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)
# @param int $page Optional page index in email list pagination (optional, default to 0)
# @param int $size Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)
# @param string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
# @param boolean $unread_only Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)
# @param string $search_filter Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)
# @param DateTime $since Optional filter emails received after given date time (optional)
# @param DateTime $before Optional filter emails received before given date time (optional)
{
    my $params = {
    'inbox_id' => {
        data_type => 'ARRAY[string]',
        description => 'Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.',
        required => '0',
    },
    'page' => {
        data_type => 'int',
        description => 'Optional page index in email list pagination',
        required => '0',
    },
    'size' => {
        data_type => 'int',
        description => 'Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results',
        required => '0',
    },
    'sort' => {
        data_type => 'string',
        description => 'Optional createdAt sort direction ASC or DESC',
        required => '0',
    },
    'unread_only' => {
        data_type => 'boolean',
        description => 'Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly',
        required => '0',
    },
    'search_filter' => {
        data_type => 'string',
        description => 'Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body',
        required => '0',
    },
    'since' => {
        data_type => 'DateTime',
        description => 'Optional filter emails received after given date time',
        required => '0',
    },
    'before' => {
        data_type => 'DateTime',
        description => 'Optional filter emails received before given date time',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_emails_offset_paginated' } = { 
        summary => 'Get all emails in all inboxes in paginated form. Email API list all.',
        params => $params,
        returns => 'PageEmailProjection',
        };
}
# @return PageEmailProjection
#
sub get_emails_offset_paginated {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/emails/offset-paginated';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'inbox_id'}) {
        $query_params->{'inboxId'} = $self->{api_client}->to_query_value($args{'inbox_id'});
    }

    # query params
    if ( exists $args{'page'}) {
        $query_params->{'page'} = $self->{api_client}->to_query_value($args{'page'});
    }

    # query params
    if ( exists $args{'size'}) {
        $query_params->{'size'} = $self->{api_client}->to_query_value($args{'size'});
    }

    # query params
    if ( exists $args{'sort'}) {
        $query_params->{'sort'} = $self->{api_client}->to_query_value($args{'sort'});
    }

    # query params
    if ( exists $args{'unread_only'}) {
        $query_params->{'unreadOnly'} = $self->{api_client}->to_query_value($args{'unread_only'});
    }

    # query params
    if ( exists $args{'search_filter'}) {
        $query_params->{'searchFilter'} = $self->{api_client}->to_query_value($args{'search_filter'});
    }

    # query params
    if ( exists $args{'since'}) {
        $query_params->{'since'} = $self->{api_client}->to_query_value($args{'since'});
    }

    # query params
    if ( exists $args{'before'}) {
        $query_params->{'before'} = $self->{api_client}->to_query_value($args{'before'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('PageEmailProjection', $response);
    return $_response_object;
}

#
# get_emails_paginated
#
# Get all emails in all inboxes in paginated form. Email API list all.
# 
# @param ARRAY[string] $inbox_id Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)
# @param int $page Optional page index in email list pagination (optional, default to 0)
# @param int $size Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)
# @param string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
# @param boolean $unread_only Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)
# @param string $search_filter Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional)
# @param DateTime $since Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)
# @param DateTime $before Optional filter emails received before given date time (optional)
{
    my $params = {
    'inbox_id' => {
        data_type => 'ARRAY[string]',
        description => 'Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.',
        required => '0',
    },
    'page' => {
        data_type => 'int',
        description => 'Optional page index in email list pagination',
        required => '0',
    },
    'size' => {
        data_type => 'int',
        description => 'Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results',
        required => '0',
    },
    'sort' => {
        data_type => 'string',
        description => 'Optional createdAt sort direction ASC or DESC',
        required => '0',
    },
    'unread_only' => {
        data_type => 'boolean',
        description => 'Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly',
        required => '0',
    },
    'search_filter' => {
        data_type => 'string',
        description => 'Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body',
        required => '0',
    },
    'since' => {
        data_type => 'DateTime',
        description => 'Optional filter emails received after given date time. If unset will use time 24hours prior to now.',
        required => '0',
    },
    'before' => {
        data_type => 'DateTime',
        description => 'Optional filter emails received before given date time',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_emails_paginated' } = { 
        summary => 'Get all emails in all inboxes in paginated form. Email API list all.',
        params => $params,
        returns => 'PageEmailProjection',
        };
}
# @return PageEmailProjection
#
sub get_emails_paginated {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/emails';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'inbox_id'}) {
        $query_params->{'inboxId'} = $self->{api_client}->to_query_value($args{'inbox_id'});
    }

    # query params
    if ( exists $args{'page'}) {
        $query_params->{'page'} = $self->{api_client}->to_query_value($args{'page'});
    }

    # query params
    if ( exists $args{'size'}) {
        $query_params->{'size'} = $self->{api_client}->to_query_value($args{'size'});
    }

    # query params
    if ( exists $args{'sort'}) {
        $query_params->{'sort'} = $self->{api_client}->to_query_value($args{'sort'});
    }

    # query params
    if ( exists $args{'unread_only'}) {
        $query_params->{'unreadOnly'} = $self->{api_client}->to_query_value($args{'unread_only'});
    }

    # query params
    if ( exists $args{'search_filter'}) {
        $query_params->{'searchFilter'} = $self->{api_client}->to_query_value($args{'search_filter'});
    }

    # query params
    if ( exists $args{'since'}) {
        $query_params->{'since'} = $self->{api_client}->to_query_value($args{'since'});
    }

    # query params
    if ( exists $args{'before'}) {
        $query_params->{'before'} = $self->{api_client}->to_query_value($args{'before'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('PageEmailProjection', $response);
    return $_response_object;
}

#
# get_gravatar_url_for_email_address
#
# 
# 
# @param string $email_address  (required)
# @param string $size  (optional)
{
    my $params = {
    'email_address' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'size' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_gravatar_url_for_email_address' } = { 
        summary => '',
        params => $params,
        returns => 'GravatarUrl',
        };
}
# @return GravatarUrl
#
sub get_gravatar_url_for_email_address {
    my ($self, %args) = @_;

    # verify the required parameter 'email_address' is set
    unless (exists $args{'email_address'}) {
      croak("Missing the required parameter 'email_address' when calling get_gravatar_url_for_email_address");
    }

    # parse inputs
    my $_resource_path = '/emails/gravatarFor';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'email_address'}) {
        $query_params->{'emailAddress'} = $self->{api_client}->to_query_value($args{'email_address'});
    }

    # query params
    if ( exists $args{'size'}) {
        $query_params->{'size'} = $self->{api_client}->to_query_value($args{'size'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('GravatarUrl', $response);
    return $_response_object;
}

#
# get_latest_email
#
# Get latest email in all inboxes. Most recently received.
# 
# @param ARRAY[string] $inbox_ids Optional set of inboxes to filter by. Only get the latest email from these inbox IDs. If not provided will search across all inboxes (optional)
{
    my $params = {
    'inbox_ids' => {
        data_type => 'ARRAY[string]',
        description => 'Optional set of inboxes to filter by. Only get the latest email from these inbox IDs. If not provided will search across all inboxes',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_latest_email' } = { 
        summary => 'Get latest email in all inboxes. Most recently received.',
        params => $params,
        returns => 'Email',
        };
}
# @return Email
#
sub get_latest_email {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/emails/latest';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'inbox_ids'}) {
        $query_params->{'inboxIds'} = $self->{api_client}->to_query_value($args{'inbox_ids'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('Email', $response);
    return $_response_object;
}

#
# get_latest_email_in_inbox1
#
# Get latest email in an inbox. Use `WaitForController` to get emails that may not have arrived yet.
# 
# @param string $inbox_id ID of the inbox you want to get the latest email from (required)
{
    my $params = {
    'inbox_id' => {
        data_type => 'string',
        description => 'ID of the inbox you want to get the latest email from',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_latest_email_in_inbox1' } = { 
        summary => 'Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet.',
        params => $params,
        returns => 'Email',
        };
}
# @return Email
#
sub get_latest_email_in_inbox1 {
    my ($self, %args) = @_;

    # verify the required parameter 'inbox_id' is set
    unless (exists $args{'inbox_id'}) {
      croak("Missing the required parameter 'inbox_id' when calling get_latest_email_in_inbox1");
    }

    # parse inputs
    my $_resource_path = '/emails/latestIn';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'inbox_id'}) {
        $query_params->{'inboxId'} = $self->{api_client}->to_query_value($args{'inbox_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('Email', $response);
    return $_response_object;
}

#
# get_organization_emails_paginated
#
# Get all organization emails. List team or shared test email accounts
# 
# @param ARRAY[string] $inbox_id Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)
# @param int $page Optional page index in email list pagination (optional, default to 0)
# @param int $size Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)
# @param string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
# @param boolean $unread_only Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)
# @param string $search_filter Optional search filter search filter for emails. (optional)
# @param DateTime $since Optional filter emails received after given date time. If unset will use time 24hours prior to now. (optional)
# @param DateTime $before Optional filter emails received before given date time (optional)
{
    my $params = {
    'inbox_id' => {
        data_type => 'ARRAY[string]',
        description => 'Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.',
        required => '0',
    },
    'page' => {
        data_type => 'int',
        description => 'Optional page index in email list pagination',
        required => '0',
    },
    'size' => {
        data_type => 'int',
        description => 'Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results',
        required => '0',
    },
    'sort' => {
        data_type => 'string',
        description => 'Optional createdAt sort direction ASC or DESC',
        required => '0',
    },
    'unread_only' => {
        data_type => 'boolean',
        description => 'Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly',
        required => '0',
    },
    'search_filter' => {
        data_type => 'string',
        description => 'Optional search filter search filter for emails.',
        required => '0',
    },
    'since' => {
        data_type => 'DateTime',
        description => 'Optional filter emails received after given date time. If unset will use time 24hours prior to now.',
        required => '0',
    },
    'before' => {
        data_type => 'DateTime',
        description => 'Optional filter emails received before given date time',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_organization_emails_paginated' } = { 
        summary => 'Get all organization emails. List team or shared test email accounts',
        params => $params,
        returns => 'PageEmailProjection',
        };
}
# @return PageEmailProjection
#
sub get_organization_emails_paginated {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/emails/organization';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'inbox_id'}) {
        $query_params->{'inboxId'} = $self->{api_client}->to_query_value($args{'inbox_id'});
    }

    # query params
    if ( exists $args{'page'}) {
        $query_params->{'page'} = $self->{api_client}->to_query_value($args{'page'});
    }

    # query params
    if ( exists $args{'size'}) {
        $query_params->{'size'} = $self->{api_client}->to_query_value($args{'size'});
    }

    # query params
    if ( exists $args{'sort'}) {
        $query_params->{'sort'} = $self->{api_client}->to_query_value($args{'sort'});
    }

    # query params
    if ( exists $args{'unread_only'}) {
        $query_params->{'unreadOnly'} = $self->{api_client}->to_query_value($args{'unread_only'});
    }

    # query params
    if ( exists $args{'search_filter'}) {
        $query_params->{'searchFilter'} = $self->{api_client}->to_query_value($args{'search_filter'});
    }

    # query params
    if ( exists $args{'since'}) {
        $query_params->{'since'} = $self->{api_client}->to_query_value($args{'since'});
    }

    # query params
    if ( exists $args{'before'}) {
        $query_params->{'before'} = $self->{api_client}->to_query_value($args{'before'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('PageEmailProjection', $response);
    return $_response_object;
}

#
# get_raw_email_contents
#
# Get raw email string. Returns unparsed raw SMTP message with headers and body.
# 
# @param string $email_id ID of email (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_raw_email_contents' } = { 
        summary => 'Get raw email string. Returns unparsed raw SMTP message with headers and body.',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub get_raw_email_contents {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling get_raw_email_contents");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/raw';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# get_raw_email_json
#
# Get raw email in JSON. Unparsed SMTP message in JSON wrapper format.
# 
# @param string $email_id ID of email (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_raw_email_json' } = { 
        summary => 'Get raw email in JSON. Unparsed SMTP message in JSON wrapper format.',
        params => $params,
        returns => 'RawEmailJson',
        };
}
# @return RawEmailJson
#
sub get_raw_email_json {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling get_raw_email_json");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/raw/json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('RawEmailJson', $response);
    return $_response_object;
}

#
# get_unread_email_count
#
# Get unread email count
# 
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'get_unread_email_count' } = { 
        summary => 'Get unread email count',
        params => $params,
        returns => 'UnreadCount',
        };
}
# @return UnreadCount
#
sub get_unread_email_count {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/emails/unreadCount';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('UnreadCount', $response);
    return $_response_object;
}

#
# mark_as_read
#
# Mark an email as read on unread
# 
# @param string $email_id  (required)
# @param boolean $read What value to assign to email read property. Default true. (optional, default to true)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'read' => {
        data_type => 'boolean',
        description => 'What value to assign to email read property. Default true.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'mark_as_read' } = { 
        summary => 'Mark an email as read on unread',
        params => $params,
        returns => 'EmailPreview',
        };
}
# @return EmailPreview
#
sub mark_as_read {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling mark_as_read");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/read';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'read'}) {
        $query_params->{'read'} = $self->{api_client}->to_query_value($args{'read'});
    }

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('EmailPreview', $response);
    return $_response_object;
}

#
# reply_to_email
#
# Reply to an email
# 
# @param string $email_id ID of the email that should be replied to (required)
# @param ReplyToEmailOptions $reply_to_email_options  (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of the email that should be replied to',
        required => '1',
    },
    'reply_to_email_options' => {
        data_type => 'ReplyToEmailOptions',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'reply_to_email' } = { 
        summary => 'Reply to an email',
        params => $params,
        returns => 'SentEmailDto',
        };
}
# @return SentEmailDto
#
sub reply_to_email {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling reply_to_email");
    }

    # verify the required parameter 'reply_to_email_options' is set
    unless (exists $args{'reply_to_email_options'}) {
      croak("Missing the required parameter 'reply_to_email_options' when calling reply_to_email");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'reply_to_email_options'}) {
        $_body_data = $args{'reply_to_email_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('SentEmailDto', $response);
    return $_response_object;
}

#
# search_emails
#
# Get all emails by search criteria. Return in paginated form.
# 
# @param SearchEmailsOptions $search_emails_options  (required)
{
    my $params = {
    'search_emails_options' => {
        data_type => 'SearchEmailsOptions',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'search_emails' } = { 
        summary => 'Get all emails by search criteria. Return in paginated form.',
        params => $params,
        returns => 'PageEmailProjection',
        };
}
# @return PageEmailProjection
#
sub search_emails {
    my ($self, %args) = @_;

    # verify the required parameter 'search_emails_options' is set
    unless (exists $args{'search_emails_options'}) {
      croak("Missing the required parameter 'search_emails_options' when calling search_emails");
    }

    # parse inputs
    my $_resource_path = '/emails/search';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'search_emails_options'}) {
        $_body_data = $args{'search_emails_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('PageEmailProjection', $response);
    return $_response_object;
}

#
# send_email_source_optional
#
# Send email
# 
# @param SendEmailOptions $send_email_options  (required)
# @param string $inbox_id ID of the inbox you want to send the email from (optional)
# @param boolean $use_domain_pool Use domain pool. Optionally create inbox to send from using the mailslurp domain pool. (optional)
# @param boolean $virtual_send Optionally create inbox to send from that is a virtual inbox and won&#39;t send to external addresses (optional)
{
    my $params = {
    'send_email_options' => {
        data_type => 'SendEmailOptions',
        description => '',
        required => '1',
    },
    'inbox_id' => {
        data_type => 'string',
        description => 'ID of the inbox you want to send the email from',
        required => '0',
    },
    'use_domain_pool' => {
        data_type => 'boolean',
        description => 'Use domain pool. Optionally create inbox to send from using the mailslurp domain pool.',
        required => '0',
    },
    'virtual_send' => {
        data_type => 'boolean',
        description => 'Optionally create inbox to send from that is a virtual inbox and won&#39;t send to external addresses',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'send_email_source_optional' } = { 
        summary => 'Send email',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub send_email_source_optional {
    my ($self, %args) = @_;

    # verify the required parameter 'send_email_options' is set
    unless (exists $args{'send_email_options'}) {
      croak("Missing the required parameter 'send_email_options' when calling send_email_source_optional");
    }

    # parse inputs
    my $_resource_path = '/emails';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # query params
    if ( exists $args{'inbox_id'}) {
        $query_params->{'inboxId'} = $self->{api_client}->to_query_value($args{'inbox_id'});
    }

    # query params
    if ( exists $args{'use_domain_pool'}) {
        $query_params->{'useDomainPool'} = $self->{api_client}->to_query_value($args{'use_domain_pool'});
    }

    # query params
    if ( exists $args{'virtual_send'}) {
        $query_params->{'virtualSend'} = $self->{api_client}->to_query_value($args{'virtual_send'});
    }

    my $_body_data;
    # body params
    if ( exists $args{'send_email_options'}) {
        $_body_data = $args{'send_email_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# validate_email
#
# Validate email HTML contents
# 
# @param string $email_id ID of email (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'validate_email' } = { 
        summary => 'Validate email HTML contents',
        params => $params,
        returns => 'ValidationDto',
        };
}
# @return ValidationDto
#
sub validate_email {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling validate_email");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/validate';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ValidationDto', $response);
    return $_response_object;
}

1;
