=begin comment

MailSlurp API

MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://www.mailslurp.com/docs/) - [Examples](https://github.com/mailslurp/examples) repository 

The version of the OpenAPI document: 6.5.2

Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
package MailSlurp::EmailControllerApi;

require 5.6.0;
use strict;
use warnings;
use utf8; 
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use MailSlurp::ApiClient;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class = shift;
    my $api_client;

    if ($_[0] && ref $_[0] && ref $_[0] eq 'MailSlurp::ApiClient' ) {
        $api_client = $_[0];
    } else {
        $api_client = MailSlurp::ApiClient->new(@_);
    }

    bless { api_client => $api_client }, $class;

}


#
# delete_all_emails
#
# Delete all emails in all inboxes.
# 
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'delete_all_emails' } = { 
        summary => 'Delete all emails in all inboxes.',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub delete_all_emails {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/emails';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# delete_email
#
# Delete an email
# 
# @param string $email_id ID of email to delete (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email to delete',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_email' } = { 
        summary => 'Delete an email',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub delete_email {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling delete_email");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# download_attachment
#
# Get email attachment bytes. Returned as `octet-stream` with content type header. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints and convert the base 64 encoded content to a file or string.
# 
# @param string $attachment_id ID of attachment (required)
# @param string $email_id ID of email (required)
# @param string $api_key Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly. (optional)
{
    my $params = {
    'attachment_id' => {
        data_type => 'string',
        description => 'ID of attachment',
        required => '1',
    },
    'email_id' => {
        data_type => 'string',
        description => 'ID of email',
        required => '1',
    },
    'api_key' => {
        data_type => 'string',
        description => 'Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'download_attachment' } = { 
        summary => 'Get email attachment bytes. Returned as &#x60;octet-stream&#x60; with content type header. If you have trouble with byte responses try the &#x60;downloadAttachmentBase64&#x60; response endpoints and convert the base 64 encoded content to a file or string.',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub download_attachment {
    my ($self, %args) = @_;

    # verify the required parameter 'attachment_id' is set
    unless (exists $args{'attachment_id'}) {
      croak("Missing the required parameter 'attachment_id' when calling download_attachment");
    }

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling download_attachment");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/attachments/{attachmentId}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/octet-stream');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'api_key'}) {
        $query_params->{'apiKey'} = $self->{api_client}->to_query_value($args{'api_key'});
    }

    # path params
    if ( exists $args{'attachment_id'}) {
        my $_base_variable = "{" . "attachmentId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'attachment_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# download_attachment_base64
#
# Get email attachment as base64 encoded string as an alternative to binary responses. Decode the `base64FileContents` as a `utf-8` encoded string or array of bytes depending on the `contentType`.
# 
# @param string $attachment_id ID of attachment (required)
# @param string $email_id ID of email (required)
{
    my $params = {
    'attachment_id' => {
        data_type => 'string',
        description => 'ID of attachment',
        required => '1',
    },
    'email_id' => {
        data_type => 'string',
        description => 'ID of email',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'download_attachment_base64' } = { 
        summary => 'Get email attachment as base64 encoded string as an alternative to binary responses. Decode the &#x60;base64FileContents&#x60; as a &#x60;utf-8&#x60; encoded string or array of bytes depending on the &#x60;contentType&#x60;.',
        params => $params,
        returns => 'DownloadAttachmentDto',
        };
}
# @return DownloadAttachmentDto
#
sub download_attachment_base64 {
    my ($self, %args) = @_;

    # verify the required parameter 'attachment_id' is set
    unless (exists $args{'attachment_id'}) {
      croak("Missing the required parameter 'attachment_id' when calling download_attachment_base64");
    }

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling download_attachment_base64");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/attachments/{attachmentId}/base64';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'attachment_id'}) {
        my $_base_variable = "{" . "attachmentId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'attachment_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('DownloadAttachmentDto', $response);
    return $_response_object;
}

#
# download_body
#
# Get email body as string. Returned as `plain/text` with content type header.
# 
# @param string $email_id ID of email (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'download_body' } = { 
        summary => 'Get email body as string. Returned as &#x60;plain/text&#x60; with content type header.',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub download_body {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling download_body");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/body';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/html', 'text/plain');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# download_body_bytes
#
# Get email body in bytes. Returned as `octet-stream` with content type header.
# 
# @param string $email_id ID of email (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'download_body_bytes' } = { 
        summary => 'Get email body in bytes. Returned as &#x60;octet-stream&#x60; with content type header.',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub download_body_bytes {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling download_body_bytes");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/body-bytes';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/octet-stream');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# forward_email
#
# Forward email to recipients
# 
# @param string $email_id ID of email (required)
# @param ForwardEmailOptions $forward_email_options forwardEmailOptions (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email',
        required => '1',
    },
    'forward_email_options' => {
        data_type => 'ForwardEmailOptions',
        description => 'forwardEmailOptions',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'forward_email' } = { 
        summary => 'Forward email to recipients',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub forward_email {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling forward_email");
    }

    # verify the required parameter 'forward_email_options' is set
    unless (exists $args{'forward_email_options'}) {
      croak("Missing the required parameter 'forward_email_options' when calling forward_email");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/forward';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'forward_email_options'}) {
        $_body_data = $args{'forward_email_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# get_attachment_meta_data
#
# Get email attachment metadata. This is the `contentType` and `contentLength` of an attachment. To get the individual attachments  use the `downloadAttachment` methods.
# 
# @param string $attachment_id ID of attachment (required)
# @param string $email_id ID of email (required)
{
    my $params = {
    'attachment_id' => {
        data_type => 'string',
        description => 'ID of attachment',
        required => '1',
    },
    'email_id' => {
        data_type => 'string',
        description => 'ID of email',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_attachment_meta_data' } = { 
        summary => 'Get email attachment metadata. This is the &#x60;contentType&#x60; and &#x60;contentLength&#x60; of an attachment. To get the individual attachments  use the &#x60;downloadAttachment&#x60; methods.',
        params => $params,
        returns => 'AttachmentMetaData',
        };
}
# @return AttachmentMetaData
#
sub get_attachment_meta_data {
    my ($self, %args) = @_;

    # verify the required parameter 'attachment_id' is set
    unless (exists $args{'attachment_id'}) {
      croak("Missing the required parameter 'attachment_id' when calling get_attachment_meta_data");
    }

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling get_attachment_meta_data");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/attachments/{attachmentId}/metadata';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'attachment_id'}) {
        my $_base_variable = "{" . "attachmentId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'attachment_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AttachmentMetaData', $response);
    return $_response_object;
}

#
# get_attachments1
#
# Get all email attachment metadata. Metadata includes name and size of attachments.
# 
# @param string $email_id ID of email (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_attachments1' } = { 
        summary => 'Get all email attachment metadata. Metadata includes name and size of attachments.',
        params => $params,
        returns => 'ARRAY[AttachmentMetaData]',
        };
}
# @return ARRAY[AttachmentMetaData]
#
sub get_attachments1 {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling get_attachments1");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/attachments';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[AttachmentMetaData]', $response);
    return $_response_object;
}

#
# get_email
#
# Get email content including headers and body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController.
# 
# @param string $email_id emailId (required)
# @param boolean $decode Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing (optional, default to false)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'emailId',
        required => '1',
    },
    'decode' => {
        data_type => 'boolean',
        description => 'Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_email' } = { 
        summary => 'Get email content including headers and body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController.',
        params => $params,
        returns => 'Email',
        };
}
# @return Email
#
sub get_email {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling get_email");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'decode'}) {
        $query_params->{'decode'} = $self->{api_client}->to_query_value($args{'decode'});
    }

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('Email', $response);
    return $_response_object;
}

#
# get_email_content_match
#
# Get email content regex pattern match results. Runs regex against email body and returns match groups.
# 
# @param string $email_id ID of email to match against (required)
# @param ContentMatchOptions $content_match_options contentMatchOptions (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email to match against',
        required => '1',
    },
    'content_match_options' => {
        data_type => 'ContentMatchOptions',
        description => 'contentMatchOptions',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_email_content_match' } = { 
        summary => 'Get email content regex pattern match results. Runs regex against email body and returns match groups.',
        params => $params,
        returns => 'EmailContentMatchResult',
        };
}
# @return EmailContentMatchResult
#
sub get_email_content_match {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling get_email_content_match");
    }

    # verify the required parameter 'content_match_options' is set
    unless (exists $args{'content_match_options'}) {
      croak("Missing the required parameter 'content_match_options' when calling get_email_content_match");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/contentMatch';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'content_match_options'}) {
        $_body_data = $args{'content_match_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('EmailContentMatchResult', $response);
    return $_response_object;
}

#
# get_email_html
#
# Get email content as HTML. For displaying emails in browser context.
# 
# @param string $email_id emailId (required)
# @param boolean $decode decode (optional, default to false)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'emailId',
        required => '1',
    },
    'decode' => {
        data_type => 'boolean',
        description => 'decode',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_email_html' } = { 
        summary => 'Get email content as HTML. For displaying emails in browser context.',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub get_email_html {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling get_email_html");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/html';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/html');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'decode'}) {
        $query_params->{'decode'} = $self->{api_client}->to_query_value($args{'decode'});
    }

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# get_email_html_query
#
# Parse and return text from an email, stripping HTML and decoding encoded characters
# 
# @param string $email_id ID of email to perform HTML query on (required)
# @param string $html_selector HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information. (optional)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email to perform HTML query on',
        required => '1',
    },
    'html_selector' => {
        data_type => 'string',
        description => 'HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_email_html_query' } = { 
        summary => 'Parse and return text from an email, stripping HTML and decoding encoded characters',
        params => $params,
        returns => 'EmailTextLinesResult',
        };
}
# @return EmailTextLinesResult
#
sub get_email_html_query {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling get_email_html_query");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/htmlQuery';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'html_selector'}) {
        $query_params->{'htmlSelector'} = $self->{api_client}->to_query_value($args{'html_selector'});
    }

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('EmailTextLinesResult', $response);
    return $_response_object;
}

#
# get_email_text_lines
#
# Parse and return text from an email, stripping HTML and decoding encoded characters
# 
# @param string $email_id ID of email to fetch text for (required)
# @param boolean $decode_html_entities Decode HTML entities (optional)
# @param string $line_separator Line separator character (optional)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email to fetch text for',
        required => '1',
    },
    'decode_html_entities' => {
        data_type => 'boolean',
        description => 'Decode HTML entities',
        required => '0',
    },
    'line_separator' => {
        data_type => 'string',
        description => 'Line separator character',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_email_text_lines' } = { 
        summary => 'Parse and return text from an email, stripping HTML and decoding encoded characters',
        params => $params,
        returns => 'EmailTextLinesResult',
        };
}
# @return EmailTextLinesResult
#
sub get_email_text_lines {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling get_email_text_lines");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/textLines';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'decode_html_entities'}) {
        $query_params->{'decodeHtmlEntities'} = $self->{api_client}->to_query_value($args{'decode_html_entities'});
    }

    # query params
    if ( exists $args{'line_separator'}) {
        $query_params->{'lineSeparator'} = $self->{api_client}->to_query_value($args{'line_separator'});
    }

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('EmailTextLinesResult', $response);
    return $_response_object;
}

#
# get_emails_paginated
#
# Get all emails in all inboxes in paginated form. Email API list all.
# 
# @param ARRAY[string] $inbox_id Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)
# @param int $page Optional page index in email list pagination (optional, default to 0)
# @param int $size Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)
# @param string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
# @param boolean $unread_only Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)
{
    my $params = {
    'inbox_id' => {
        data_type => 'ARRAY[string]',
        description => 'Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.',
        required => '0',
    },
    'page' => {
        data_type => 'int',
        description => 'Optional page index in email list pagination',
        required => '0',
    },
    'size' => {
        data_type => 'int',
        description => 'Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results',
        required => '0',
    },
    'sort' => {
        data_type => 'string',
        description => 'Optional createdAt sort direction ASC or DESC',
        required => '0',
    },
    'unread_only' => {
        data_type => 'boolean',
        description => 'Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_emails_paginated' } = { 
        summary => 'Get all emails in all inboxes in paginated form. Email API list all.',
        params => $params,
        returns => 'PageEmailProjection',
        };
}
# @return PageEmailProjection
#
sub get_emails_paginated {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/emails';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'inbox_id'}) {
        $query_params->{'inboxId'} = $self->{api_client}->to_query_value($args{'inbox_id'});
    }

    # query params
    if ( exists $args{'page'}) {
        $query_params->{'page'} = $self->{api_client}->to_query_value($args{'page'});
    }

    # query params
    if ( exists $args{'size'}) {
        $query_params->{'size'} = $self->{api_client}->to_query_value($args{'size'});
    }

    # query params
    if ( exists $args{'sort'}) {
        $query_params->{'sort'} = $self->{api_client}->to_query_value($args{'sort'});
    }

    # query params
    if ( exists $args{'unread_only'}) {
        $query_params->{'unreadOnly'} = $self->{api_client}->to_query_value($args{'unread_only'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('PageEmailProjection', $response);
    return $_response_object;
}

#
# get_latest_email
#
# Get latest email in all inboxes. Most recently received.
# 
# @param ARRAY[string] $inbox_ids Optional set of inboxes to filter by. Only get the latest email from these inbox IDs (optional)
{
    my $params = {
    'inbox_ids' => {
        data_type => 'ARRAY[string]',
        description => 'Optional set of inboxes to filter by. Only get the latest email from these inbox IDs',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_latest_email' } = { 
        summary => 'Get latest email in all inboxes. Most recently received.',
        params => $params,
        returns => 'Email',
        };
}
# @return Email
#
sub get_latest_email {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/emails/latest';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'inbox_ids'}) {
        $query_params->{'inboxIds'} = $self->{api_client}->to_query_value($args{'inbox_ids'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('Email', $response);
    return $_response_object;
}

#
# get_latest_email_in_inbox
#
# Get latest email in an inbox. Use `WaitForController` to get emails that may not have arrived yet.
# 
# @param string $inbox_id ID of the inbox you want to get the latest email from (optional)
{
    my $params = {
    'inbox_id' => {
        data_type => 'string',
        description => 'ID of the inbox you want to get the latest email from',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_latest_email_in_inbox' } = { 
        summary => 'Get latest email in an inbox. Use &#x60;WaitForController&#x60; to get emails that may not have arrived yet.',
        params => $params,
        returns => 'Email',
        };
}
# @return Email
#
sub get_latest_email_in_inbox {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/emails/latestIn';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'inbox_id'}) {
        $query_params->{'inboxId'} = $self->{api_client}->to_query_value($args{'inbox_id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('Email', $response);
    return $_response_object;
}

#
# get_organization_emails_paginated
#
# Get all organization emails. List team or shared test email accounts
# 
# @param ARRAY[string] $inbox_id Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)
# @param int $page Optional page index in email list pagination (optional, default to 0)
# @param int $size Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)
# @param string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
# @param boolean $unread_only Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)
{
    my $params = {
    'inbox_id' => {
        data_type => 'ARRAY[string]',
        description => 'Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.',
        required => '0',
    },
    'page' => {
        data_type => 'int',
        description => 'Optional page index in email list pagination',
        required => '0',
    },
    'size' => {
        data_type => 'int',
        description => 'Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results',
        required => '0',
    },
    'sort' => {
        data_type => 'string',
        description => 'Optional createdAt sort direction ASC or DESC',
        required => '0',
    },
    'unread_only' => {
        data_type => 'boolean',
        description => 'Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_organization_emails_paginated' } = { 
        summary => 'Get all organization emails. List team or shared test email accounts',
        params => $params,
        returns => 'PageEmailProjection',
        };
}
# @return PageEmailProjection
#
sub get_organization_emails_paginated {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/emails/organization';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'inbox_id'}) {
        $query_params->{'inboxId'} = $self->{api_client}->to_query_value($args{'inbox_id'});
    }

    # query params
    if ( exists $args{'page'}) {
        $query_params->{'page'} = $self->{api_client}->to_query_value($args{'page'});
    }

    # query params
    if ( exists $args{'size'}) {
        $query_params->{'size'} = $self->{api_client}->to_query_value($args{'size'});
    }

    # query params
    if ( exists $args{'sort'}) {
        $query_params->{'sort'} = $self->{api_client}->to_query_value($args{'sort'});
    }

    # query params
    if ( exists $args{'unread_only'}) {
        $query_params->{'unreadOnly'} = $self->{api_client}->to_query_value($args{'unread_only'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('PageEmailProjection', $response);
    return $_response_object;
}

#
# get_raw_email_contents
#
# Get raw email string. Returns unparsed raw SMTP message with headers and body.
# 
# @param string $email_id ID of email (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_raw_email_contents' } = { 
        summary => 'Get raw email string. Returns unparsed raw SMTP message with headers and body.',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub get_raw_email_contents {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling get_raw_email_contents");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/raw';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# get_raw_email_json
#
# Get raw email in JSON. Unparsed SMTP message in JSON wrapper format.
# 
# @param string $email_id ID of email (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_raw_email_json' } = { 
        summary => 'Get raw email in JSON. Unparsed SMTP message in JSON wrapper format.',
        params => $params,
        returns => 'RawEmailJson',
        };
}
# @return RawEmailJson
#
sub get_raw_email_json {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling get_raw_email_json");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/raw/json';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('RawEmailJson', $response);
    return $_response_object;
}

#
# get_unread_email_count
#
# Get unread email count
# 
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'get_unread_email_count' } = { 
        summary => 'Get unread email count',
        params => $params,
        returns => 'UnreadCount',
        };
}
# @return UnreadCount
#
sub get_unread_email_count {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/emails/unreadCount';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('UnreadCount', $response);
    return $_response_object;
}

#
# reply_to_email
#
# Reply to an email
# 
# @param string $email_id ID of the email that should be replied to (required)
# @param ReplyToEmailOptions $reply_to_email_options replyToEmailOptions (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of the email that should be replied to',
        required => '1',
    },
    'reply_to_email_options' => {
        data_type => 'ReplyToEmailOptions',
        description => 'replyToEmailOptions',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'reply_to_email' } = { 
        summary => 'Reply to an email',
        params => $params,
        returns => 'SentEmailDto',
        };
}
# @return SentEmailDto
#
sub reply_to_email {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling reply_to_email");
    }

    # verify the required parameter 'reply_to_email_options' is set
    unless (exists $args{'reply_to_email_options'}) {
      croak("Missing the required parameter 'reply_to_email_options' when calling reply_to_email");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'reply_to_email_options'}) {
        $_body_data = $args{'reply_to_email_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('SentEmailDto', $response);
    return $_response_object;
}

#
# validate_email
#
# Validate email HTML contents
# 
# @param string $email_id ID of email (required)
{
    my $params = {
    'email_id' => {
        data_type => 'string',
        description => 'ID of email',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'validate_email' } = { 
        summary => 'Validate email HTML contents',
        params => $params,
        returns => 'ValidationDto',
        };
}
# @return ValidationDto
#
sub validate_email {
    my ($self, %args) = @_;

    # verify the required parameter 'email_id' is set
    unless (exists $args{'email_id'}) {
      croak("Missing the required parameter 'email_id' when calling validate_email");
    }

    # parse inputs
    my $_resource_path = '/emails/{emailId}/validate';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'email_id'}) {
        my $_base_variable = "{" . "emailId" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'email_id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ValidationDto', $response);
    return $_response_object;
}

1;
