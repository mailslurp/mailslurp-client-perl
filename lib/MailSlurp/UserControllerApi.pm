=begin comment

MailSlurp API

MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository

The version of the OpenAPI document: 6.5.2
Contact: contact@mailslurp.dev
Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
package MailSlurp::UserControllerApi;

require 5.6.0;
use strict;
use warnings;
use utf8; 
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use MailSlurp::ApiClient;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class = shift;
    my $api_client;

    if ($_[0] && ref $_[0] && ref $_[0] eq 'MailSlurp::ApiClient' ) {
        $api_client = $_[0];
    } else {
        $api_client = MailSlurp::ApiClient->new(@_);
    }

    bless { api_client => $api_client }, $class;

}


#
# get_entity_automations
#
# 
# 
# @param int $page Optional page index (optional, default to 0)
# @param int $size Optional page size (optional, default to 20)
# @param string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'DESC')
# @param DateTime $since Filter by created at after the given timestamp (optional)
# @param DateTime $before Filter by created at before the given timestamp (optional)
# @param string $inbox_id Optional inbox ID (optional)
# @param string $phone_id Optional phone ID (optional)
# @param string $filter Optional automation type filter (optional)
{
    my $params = {
    'page' => {
        data_type => 'int',
        description => 'Optional page index',
        required => '0',
    },
    'size' => {
        data_type => 'int',
        description => 'Optional page size',
        required => '0',
    },
    'sort' => {
        data_type => 'string',
        description => 'Optional createdAt sort direction ASC or DESC',
        required => '0',
    },
    'since' => {
        data_type => 'DateTime',
        description => 'Filter by created at after the given timestamp',
        required => '0',
    },
    'before' => {
        data_type => 'DateTime',
        description => 'Filter by created at before the given timestamp',
        required => '0',
    },
    'inbox_id' => {
        data_type => 'string',
        description => 'Optional inbox ID',
        required => '0',
    },
    'phone_id' => {
        data_type => 'string',
        description => 'Optional phone ID',
        required => '0',
    },
    'filter' => {
        data_type => 'string',
        description => 'Optional automation type filter',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_entity_automations' } = { 
        summary => '',
        params => $params,
        returns => 'PageEntityAutomationItems',
        };
}
# @return PageEntityAutomationItems
#
sub get_entity_automations {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/user/automations';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'page'}) {
        $query_params->{'page'} = $self->{api_client}->to_query_value($args{'page'});
    }

    # query params
    if ( exists $args{'size'}) {
        $query_params->{'size'} = $self->{api_client}->to_query_value($args{'size'});
    }

    # query params
    if ( exists $args{'sort'}) {
        $query_params->{'sort'} = $self->{api_client}->to_query_value($args{'sort'});
    }

    # query params
    if ( exists $args{'since'}) {
        $query_params->{'since'} = $self->{api_client}->to_query_value($args{'since'});
    }

    # query params
    if ( exists $args{'before'}) {
        $query_params->{'before'} = $self->{api_client}->to_query_value($args{'before'});
    }

    # query params
    if ( exists $args{'inbox_id'}) {
        $query_params->{'inboxId'} = $self->{api_client}->to_query_value($args{'inbox_id'});
    }

    # query params
    if ( exists $args{'phone_id'}) {
        $query_params->{'phoneId'} = $self->{api_client}->to_query_value($args{'phone_id'});
    }

    # query params
    if ( exists $args{'filter'}) {
        $query_params->{'filter'} = $self->{api_client}->to_query_value($args{'filter'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('PageEntityAutomationItems', $response);
    return $_response_object;
}

#
# get_entity_events
#
# 
# 
# @param int $page Optional page index (optional, default to 0)
# @param int $size Optional page size (optional, default to 20)
# @param string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'DESC')
# @param DateTime $since Filter by created at after the given timestamp (optional)
# @param DateTime $before Filter by created at before the given timestamp (optional)
# @param string $inbox_id Optional inbox ID (optional)
# @param string $email_id Optional email ID (optional)
# @param string $phone_id Optional phone ID (optional)
# @param string $sms_id Optional SMS ID (optional)
# @param string $attachment_id Optional attachment ID (optional)
# @param string $filter Optional type filter (optional)
{
    my $params = {
    'page' => {
        data_type => 'int',
        description => 'Optional page index',
        required => '0',
    },
    'size' => {
        data_type => 'int',
        description => 'Optional page size',
        required => '0',
    },
    'sort' => {
        data_type => 'string',
        description => 'Optional createdAt sort direction ASC or DESC',
        required => '0',
    },
    'since' => {
        data_type => 'DateTime',
        description => 'Filter by created at after the given timestamp',
        required => '0',
    },
    'before' => {
        data_type => 'DateTime',
        description => 'Filter by created at before the given timestamp',
        required => '0',
    },
    'inbox_id' => {
        data_type => 'string',
        description => 'Optional inbox ID',
        required => '0',
    },
    'email_id' => {
        data_type => 'string',
        description => 'Optional email ID',
        required => '0',
    },
    'phone_id' => {
        data_type => 'string',
        description => 'Optional phone ID',
        required => '0',
    },
    'sms_id' => {
        data_type => 'string',
        description => 'Optional SMS ID',
        required => '0',
    },
    'attachment_id' => {
        data_type => 'string',
        description => 'Optional attachment ID',
        required => '0',
    },
    'filter' => {
        data_type => 'string',
        description => 'Optional type filter',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_entity_events' } = { 
        summary => '',
        params => $params,
        returns => 'PageEntityEventItems',
        };
}
# @return PageEntityEventItems
#
sub get_entity_events {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/user/events';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'page'}) {
        $query_params->{'page'} = $self->{api_client}->to_query_value($args{'page'});
    }

    # query params
    if ( exists $args{'size'}) {
        $query_params->{'size'} = $self->{api_client}->to_query_value($args{'size'});
    }

    # query params
    if ( exists $args{'sort'}) {
        $query_params->{'sort'} = $self->{api_client}->to_query_value($args{'sort'});
    }

    # query params
    if ( exists $args{'since'}) {
        $query_params->{'since'} = $self->{api_client}->to_query_value($args{'since'});
    }

    # query params
    if ( exists $args{'before'}) {
        $query_params->{'before'} = $self->{api_client}->to_query_value($args{'before'});
    }

    # query params
    if ( exists $args{'inbox_id'}) {
        $query_params->{'inboxId'} = $self->{api_client}->to_query_value($args{'inbox_id'});
    }

    # query params
    if ( exists $args{'email_id'}) {
        $query_params->{'emailId'} = $self->{api_client}->to_query_value($args{'email_id'});
    }

    # query params
    if ( exists $args{'phone_id'}) {
        $query_params->{'phoneId'} = $self->{api_client}->to_query_value($args{'phone_id'});
    }

    # query params
    if ( exists $args{'sms_id'}) {
        $query_params->{'smsId'} = $self->{api_client}->to_query_value($args{'sms_id'});
    }

    # query params
    if ( exists $args{'attachment_id'}) {
        $query_params->{'attachmentId'} = $self->{api_client}->to_query_value($args{'attachment_id'});
    }

    # query params
    if ( exists $args{'filter'}) {
        $query_params->{'filter'} = $self->{api_client}->to_query_value($args{'filter'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('PageEntityEventItems', $response);
    return $_response_object;
}

#
# get_entity_favorites
#
# 
# 
# @param int $page Optional page index (optional, default to 0)
# @param int $size Optional page size (optional, default to 20)
# @param string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'DESC')
# @param DateTime $since Filter by created at after the given timestamp (optional)
# @param DateTime $before Filter by created at before the given timestamp (optional)
# @param string $filter Optional type filter (optional)
{
    my $params = {
    'page' => {
        data_type => 'int',
        description => 'Optional page index',
        required => '0',
    },
    'size' => {
        data_type => 'int',
        description => 'Optional page size',
        required => '0',
    },
    'sort' => {
        data_type => 'string',
        description => 'Optional createdAt sort direction ASC or DESC',
        required => '0',
    },
    'since' => {
        data_type => 'DateTime',
        description => 'Filter by created at after the given timestamp',
        required => '0',
    },
    'before' => {
        data_type => 'DateTime',
        description => 'Filter by created at before the given timestamp',
        required => '0',
    },
    'filter' => {
        data_type => 'string',
        description => 'Optional type filter',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_entity_favorites' } = { 
        summary => '',
        params => $params,
        returns => 'PageEntityFavouriteItems',
        };
}
# @return PageEntityFavouriteItems
#
sub get_entity_favorites {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/user/favorites';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'page'}) {
        $query_params->{'page'} = $self->{api_client}->to_query_value($args{'page'});
    }

    # query params
    if ( exists $args{'size'}) {
        $query_params->{'size'} = $self->{api_client}->to_query_value($args{'size'});
    }

    # query params
    if ( exists $args{'sort'}) {
        $query_params->{'sort'} = $self->{api_client}->to_query_value($args{'sort'});
    }

    # query params
    if ( exists $args{'since'}) {
        $query_params->{'since'} = $self->{api_client}->to_query_value($args{'since'});
    }

    # query params
    if ( exists $args{'before'}) {
        $query_params->{'before'} = $self->{api_client}->to_query_value($args{'before'});
    }

    # query params
    if ( exists $args{'filter'}) {
        $query_params->{'filter'} = $self->{api_client}->to_query_value($args{'filter'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('PageEntityFavouriteItems', $response);
    return $_response_object;
}

#
# get_json_property_as_string
#
# 
# 
# @param string $property JSON property name or dot separated path selector such as &#x60;a.b.c&#x60; (required)
# @param object $body  (required)
{
    my $params = {
    'property' => {
        data_type => 'string',
        description => 'JSON property name or dot separated path selector such as &#x60;a.b.c&#x60;',
        required => '1',
    },
    'body' => {
        data_type => 'object',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_json_property_as_string' } = { 
        summary => '',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub get_json_property_as_string {
    my ($self, %args) = @_;

    # verify the required parameter 'property' is set
    unless (exists $args{'property'}) {
      croak("Missing the required parameter 'property' when calling get_json_property_as_string");
    }

    # parse inputs
    my $_resource_path = '/user/json/pluck';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # query params
    if ( exists $args{'property'}) {
        $query_params->{'property'} = $self->{api_client}->to_query_value($args{'property'});
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# get_user_info
#
# 
# 
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'get_user_info' } = { 
        summary => '',
        params => $params,
        returns => 'UserInfoDto',
        };
}
# @return UserInfoDto
#
sub get_user_info {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/user/info';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('UserInfoDto', $response);
    return $_response_object;
}

1;
