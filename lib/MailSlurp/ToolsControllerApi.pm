=begin comment

MailSlurp API

MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository

The version of the OpenAPI document: 6.5.2
Contact: contact@mailslurp.dev
Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
package MailSlurp::ToolsControllerApi;

require 5.6.0;
use strict;
use warnings;
use utf8; 
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use MailSlurp::ApiClient;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class = shift;
    my $api_client;

    if ($_[0] && ref $_[0] && ref $_[0] eq 'MailSlurp::ApiClient' ) {
        $api_client = $_[0];
    } else {
        $api_client = MailSlurp::ApiClient->new(@_);
    }

    bless { api_client => $api_client }, $class;

}


#
# check_email_features_client_support
#
# Check email client support for email HTML and CSS features
# 
# @param CheckEmailFeaturesClientSupportOptions $check_email_features_client_support_options  (required)
{
    my $params = {
    'check_email_features_client_support_options' => {
        data_type => 'CheckEmailFeaturesClientSupportOptions',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'check_email_features_client_support' } = { 
        summary => 'Check email client support for email HTML and CSS features',
        params => $params,
        returns => 'CheckEmailFeaturesClientSupportResults',
        };
}
# @return CheckEmailFeaturesClientSupportResults
#
sub check_email_features_client_support {
    my ($self, %args) = @_;

    # verify the required parameter 'check_email_features_client_support_options' is set
    unless (exists $args{'check_email_features_client_support_options'}) {
      croak("Missing the required parameter 'check_email_features_client_support_options' when calling check_email_features_client_support");
    }

    # parse inputs
    my $_resource_path = '/tools/check-email-features-client-support';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'check_email_features_client_support_options'}) {
        $_body_data = $args{'check_email_features_client_support_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('CheckEmailFeaturesClientSupportResults', $response);
    return $_response_object;
}

#
# create_new_fake_email_address
#
# Create a new email address using the fake email domains
# 
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'create_new_fake_email_address' } = { 
        summary => 'Create a new email address using the fake email domains',
        params => $params,
        returns => 'NewFakeEmailAddressResult',
        };
}
# @return NewFakeEmailAddressResult
#
sub create_new_fake_email_address {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/tools/fake-email';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('NewFakeEmailAddressResult', $response);
    return $_response_object;
}

#
# delete_new_fake_email_address
#
# Delete a fake email address using the fake email domains
# 
# @param string $email_address  (required)
{
    my $params = {
    'email_address' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_new_fake_email_address' } = { 
        summary => 'Delete a fake email address using the fake email domains',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub delete_new_fake_email_address {
    my ($self, %args) = @_;

    # verify the required parameter 'email_address' is set
    unless (exists $args{'email_address'}) {
      croak("Missing the required parameter 'email_address' when calling delete_new_fake_email_address");
    }

    # parse inputs
    my $_resource_path = '/tools/fake-email';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'email_address'}) {
        $query_params->{'emailAddress'} = $self->{api_client}->to_query_value($args{'email_address'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# generate_bimi_record
#
# Create a BIMI record policy
# 
# @param GenerateBimiRecordOptions $generate_bimi_record_options  (required)
{
    my $params = {
    'generate_bimi_record_options' => {
        data_type => 'GenerateBimiRecordOptions',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'generate_bimi_record' } = { 
        summary => 'Create a BIMI record policy',
        params => $params,
        returns => 'GenerateBimiRecordResults',
        };
}
# @return GenerateBimiRecordResults
#
sub generate_bimi_record {
    my ($self, %args) = @_;

    # verify the required parameter 'generate_bimi_record_options' is set
    unless (exists $args{'generate_bimi_record_options'}) {
      croak("Missing the required parameter 'generate_bimi_record_options' when calling generate_bimi_record");
    }

    # parse inputs
    my $_resource_path = '/tools/generate-bimi-record';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'generate_bimi_record_options'}) {
        $_body_data = $args{'generate_bimi_record_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('GenerateBimiRecordResults', $response);
    return $_response_object;
}

#
# generate_dmarc_record
#
# Create a DMARC record policy
# 
# @param GenerateDmarcRecordOptions $generate_dmarc_record_options  (required)
{
    my $params = {
    'generate_dmarc_record_options' => {
        data_type => 'GenerateDmarcRecordOptions',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'generate_dmarc_record' } = { 
        summary => 'Create a DMARC record policy',
        params => $params,
        returns => 'GenerateDmarcRecordResults',
        };
}
# @return GenerateDmarcRecordResults
#
sub generate_dmarc_record {
    my ($self, %args) = @_;

    # verify the required parameter 'generate_dmarc_record_options' is set
    unless (exists $args{'generate_dmarc_record_options'}) {
      croak("Missing the required parameter 'generate_dmarc_record_options' when calling generate_dmarc_record");
    }

    # parse inputs
    my $_resource_path = '/tools/generate-dmarc-record';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'generate_dmarc_record_options'}) {
        $_body_data = $args{'generate_dmarc_record_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('GenerateDmarcRecordResults', $response);
    return $_response_object;
}

#
# generate_mta_sts_record
#
# Create a TLS reporting record policy
# 
# @param GenerateMtaStsRecordOptions $generate_mta_sts_record_options  (required)
{
    my $params = {
    'generate_mta_sts_record_options' => {
        data_type => 'GenerateMtaStsRecordOptions',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'generate_mta_sts_record' } = { 
        summary => 'Create a TLS reporting record policy',
        params => $params,
        returns => 'GenerateMtaStsRecordResults',
        };
}
# @return GenerateMtaStsRecordResults
#
sub generate_mta_sts_record {
    my ($self, %args) = @_;

    # verify the required parameter 'generate_mta_sts_record_options' is set
    unless (exists $args{'generate_mta_sts_record_options'}) {
      croak("Missing the required parameter 'generate_mta_sts_record_options' when calling generate_mta_sts_record");
    }

    # parse inputs
    my $_resource_path = '/tools/generate-mta-sts-record';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'generate_mta_sts_record_options'}) {
        $_body_data = $args{'generate_mta_sts_record_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('GenerateMtaStsRecordResults', $response);
    return $_response_object;
}

#
# generate_tls_reporting_record
#
# Create a TLS reporting record policy
# 
# @param GenerateTlsReportingRecordOptions $generate_tls_reporting_record_options  (required)
{
    my $params = {
    'generate_tls_reporting_record_options' => {
        data_type => 'GenerateTlsReportingRecordOptions',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'generate_tls_reporting_record' } = { 
        summary => 'Create a TLS reporting record policy',
        params => $params,
        returns => 'GenerateTlsReportingRecordResults',
        };
}
# @return GenerateTlsReportingRecordResults
#
sub generate_tls_reporting_record {
    my ($self, %args) = @_;

    # verify the required parameter 'generate_tls_reporting_record_options' is set
    unless (exists $args{'generate_tls_reporting_record_options'}) {
      croak("Missing the required parameter 'generate_tls_reporting_record_options' when calling generate_tls_reporting_record");
    }

    # parse inputs
    my $_resource_path = '/tools/generate-tls-reporting-record';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'generate_tls_reporting_record_options'}) {
        $_body_data = $args{'generate_tls_reporting_record_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('GenerateTlsReportingRecordResults', $response);
    return $_response_object;
}

#
# get_fake_email_by_email_address
#
# 
# 
# @param string $email_address  (required)
{
    my $params = {
    'email_address' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_fake_email_by_email_address' } = { 
        summary => '',
        params => $params,
        returns => 'FakeEmailResult',
        };
}
# @return FakeEmailResult
#
sub get_fake_email_by_email_address {
    my ($self, %args) = @_;

    # verify the required parameter 'email_address' is set
    unless (exists $args{'email_address'}) {
      croak("Missing the required parameter 'email_address' when calling get_fake_email_by_email_address");
    }

    # parse inputs
    my $_resource_path = '/tools/fake-email/byEmailAddress';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'email_address'}) {
        $query_params->{'emailAddress'} = $self->{api_client}->to_query_value($args{'email_address'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('FakeEmailResult', $response);
    return $_response_object;
}

#
# get_fake_email_by_id
#
# Get a fake email by its ID
# 
# @param string $id  (required)
{
    my $params = {
    'id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_fake_email_by_id' } = { 
        summary => 'Get a fake email by its ID',
        params => $params,
        returns => 'FakeEmailResult',
        };
}
# @return FakeEmailResult
#
sub get_fake_email_by_id {
    my ($self, %args) = @_;

    # verify the required parameter 'id' is set
    unless (exists $args{'id'}) {
      croak("Missing the required parameter 'id' when calling get_fake_email_by_id");
    }

    # parse inputs
    my $_resource_path = '/tools/fake-email';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'id'}) {
        $query_params->{'id'} = $self->{api_client}->to_query_value($args{'id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('FakeEmailResult', $response);
    return $_response_object;
}

#
# get_fake_email_raw
#
# Get raw fake email content
# 
# @param string $id  (required)
{
    my $params = {
    'id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_fake_email_raw' } = { 
        summary => 'Get raw fake email content',
        params => $params,
        returns => 'string',
        };
}
# @return string
#
sub get_fake_email_raw {
    my ($self, %args) = @_;

    # verify the required parameter 'id' is set
    unless (exists $args{'id'}) {
      croak("Missing the required parameter 'id' when calling get_fake_email_raw");
    }

    # parse inputs
    my $_resource_path = '/tools/fake-email/html';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('text/plain;charset=utf-8', 'text/html;charset=utf-8', 'text/plain; charset=utf-8', 'text/html; charset=utf-8');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'id'}) {
        $query_params->{'id'} = $self->{api_client}->to_query_value($args{'id'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('string', $response);
    return $_response_object;
}

#
# get_fake_emails_for_address
#
# Get fake emails for an address
# 
# @param string $email_address  (required)
# @param int $page  (optional)
{
    my $params = {
    'email_address' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    'page' => {
        data_type => 'int',
        description => '',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_fake_emails_for_address' } = { 
        summary => 'Get fake emails for an address',
        params => $params,
        returns => 'ARRAY[FakeEmailPreview]',
        };
}
# @return ARRAY[FakeEmailPreview]
#
sub get_fake_emails_for_address {
    my ($self, %args) = @_;

    # verify the required parameter 'email_address' is set
    unless (exists $args{'email_address'}) {
      croak("Missing the required parameter 'email_address' when calling get_fake_emails_for_address");
    }

    # parse inputs
    my $_resource_path = '/tools/fake-emails';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'page'}) {
        $query_params->{'page'} = $self->{api_client}->to_query_value($args{'page'});
    }

    # query params
    if ( exists $args{'email_address'}) {
        $query_params->{'emailAddress'} = $self->{api_client}->to_query_value($args{'email_address'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[FakeEmailPreview]', $response);
    return $_response_object;
}

#
# lookup_bimi_domain
#
# Lookup a BIMI record policy
# 
# @param LookupBimiDomainOptions $lookup_bimi_domain_options  (required)
{
    my $params = {
    'lookup_bimi_domain_options' => {
        data_type => 'LookupBimiDomainOptions',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'lookup_bimi_domain' } = { 
        summary => 'Lookup a BIMI record policy',
        params => $params,
        returns => 'LookupBimiDomainResults',
        };
}
# @return LookupBimiDomainResults
#
sub lookup_bimi_domain {
    my ($self, %args) = @_;

    # verify the required parameter 'lookup_bimi_domain_options' is set
    unless (exists $args{'lookup_bimi_domain_options'}) {
      croak("Missing the required parameter 'lookup_bimi_domain_options' when calling lookup_bimi_domain");
    }

    # parse inputs
    my $_resource_path = '/tools/lookup-bimi-domain';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'lookup_bimi_domain_options'}) {
        $_body_data = $args{'lookup_bimi_domain_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('LookupBimiDomainResults', $response);
    return $_response_object;
}

#
# lookup_dmarc_domain
#
# Lookup a DMARC record policy
# 
# @param LookupDmarcDomainOptions $lookup_dmarc_domain_options  (required)
{
    my $params = {
    'lookup_dmarc_domain_options' => {
        data_type => 'LookupDmarcDomainOptions',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'lookup_dmarc_domain' } = { 
        summary => 'Lookup a DMARC record policy',
        params => $params,
        returns => 'LookupDmarcDomainResults',
        };
}
# @return LookupDmarcDomainResults
#
sub lookup_dmarc_domain {
    my ($self, %args) = @_;

    # verify the required parameter 'lookup_dmarc_domain_options' is set
    unless (exists $args{'lookup_dmarc_domain_options'}) {
      croak("Missing the required parameter 'lookup_dmarc_domain_options' when calling lookup_dmarc_domain");
    }

    # parse inputs
    my $_resource_path = '/tools/lookup-dmarc-domain';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'lookup_dmarc_domain_options'}) {
        $_body_data = $args{'lookup_dmarc_domain_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('LookupDmarcDomainResults', $response);
    return $_response_object;
}

#
# lookup_mta_sts_domain
#
# Lookup a MTA-STS domain policy
# 
# @param LookupMtaStsDomainOptions $lookup_mta_sts_domain_options  (required)
{
    my $params = {
    'lookup_mta_sts_domain_options' => {
        data_type => 'LookupMtaStsDomainOptions',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'lookup_mta_sts_domain' } = { 
        summary => 'Lookup a MTA-STS domain policy',
        params => $params,
        returns => 'LookupMtaStsDomainResults',
        };
}
# @return LookupMtaStsDomainResults
#
sub lookup_mta_sts_domain {
    my ($self, %args) = @_;

    # verify the required parameter 'lookup_mta_sts_domain_options' is set
    unless (exists $args{'lookup_mta_sts_domain_options'}) {
      croak("Missing the required parameter 'lookup_mta_sts_domain_options' when calling lookup_mta_sts_domain");
    }

    # parse inputs
    my $_resource_path = '/tools/lookup-mta-sts-domain';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'lookup_mta_sts_domain_options'}) {
        $_body_data = $args{'lookup_mta_sts_domain_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('LookupMtaStsDomainResults', $response);
    return $_response_object;
}

#
# lookup_mx_record
#
# Lookup a MX records for a domain
# 
# @param LookupMxRecordsOptions $lookup_mx_records_options  (required)
{
    my $params = {
    'lookup_mx_records_options' => {
        data_type => 'LookupMxRecordsOptions',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'lookup_mx_record' } = { 
        summary => 'Lookup a MX records for a domain',
        params => $params,
        returns => 'LookupMxRecordsResults',
        };
}
# @return LookupMxRecordsResults
#
sub lookup_mx_record {
    my ($self, %args) = @_;

    # verify the required parameter 'lookup_mx_records_options' is set
    unless (exists $args{'lookup_mx_records_options'}) {
      croak("Missing the required parameter 'lookup_mx_records_options' when calling lookup_mx_record");
    }

    # parse inputs
    my $_resource_path = '/tools/lookup-mx-records';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'lookup_mx_records_options'}) {
        $_body_data = $args{'lookup_mx_records_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('LookupMxRecordsResults', $response);
    return $_response_object;
}

#
# lookup_tls_reporting_domain
#
# Lookup a TLS reporting domain policy
# 
# @param LookupTlsReportingDomainOptions $lookup_tls_reporting_domain_options  (required)
{
    my $params = {
    'lookup_tls_reporting_domain_options' => {
        data_type => 'LookupTlsReportingDomainOptions',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'lookup_tls_reporting_domain' } = { 
        summary => 'Lookup a TLS reporting domain policy',
        params => $params,
        returns => 'LookupTlsReportingDomainResults',
        };
}
# @return LookupTlsReportingDomainResults
#
sub lookup_tls_reporting_domain {
    my ($self, %args) = @_;

    # verify the required parameter 'lookup_tls_reporting_domain_options' is set
    unless (exists $args{'lookup_tls_reporting_domain_options'}) {
      croak("Missing the required parameter 'lookup_tls_reporting_domain_options' when calling lookup_tls_reporting_domain");
    }

    # parse inputs
    my $_resource_path = '/tools/lookup-tls-reporting-domain';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'lookup_tls_reporting_domain_options'}) {
        $_body_data = $args{'lookup_tls_reporting_domain_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('LookupTlsReportingDomainResults', $response);
    return $_response_object;
}

1;
