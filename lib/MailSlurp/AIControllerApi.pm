=begin comment

MailSlurp API

MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository

The version of the OpenAPI document: 6.5.2
Contact: contact@mailslurp.dev
Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
package MailSlurp::AIControllerApi;

require 5.6.0;
use strict;
use warnings;
use utf8; 
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use MailSlurp::ApiClient;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class = shift;
    my $api_client;

    if ($_[0] && ref $_[0] && ref $_[0] eq 'MailSlurp::ApiClient' ) {
        $api_client = $_[0];
    } else {
        $api_client = MailSlurp::ApiClient->new(@_);
    }

    bless { api_client => $api_client }, $class;

}


#
# create_transformer
#
# Create a transformer for reuse in automations
# 
# @param AITransformCreateOptions $ai_transform_create_options  (required)
{
    my $params = {
    'ai_transform_create_options' => {
        data_type => 'AITransformCreateOptions',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_transformer' } = { 
        summary => 'Create a transformer for reuse in automations',
        params => $params,
        returns => 'AITransformDto',
        };
}
# @return AITransformDto
#
sub create_transformer {
    my ($self, %args) = @_;

    # verify the required parameter 'ai_transform_create_options' is set
    unless (exists $args{'ai_transform_create_options'}) {
      croak("Missing the required parameter 'ai_transform_create_options' when calling create_transformer");
    }

    # parse inputs
    my $_resource_path = '/ai/transformer';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'ai_transform_create_options'}) {
        $_body_data = $args{'ai_transform_create_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AITransformDto', $response);
    return $_response_object;
}

#
# create_transformer_mappings
#
# Create transformer mapping
# 
# @param CreateAITransformerMappingOptions $create_ai_transformer_mapping_options  (required)
{
    my $params = {
    'create_ai_transformer_mapping_options' => {
        data_type => 'CreateAITransformerMappingOptions',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'create_transformer_mappings' } = { 
        summary => 'Create transformer mapping',
        params => $params,
        returns => 'AITransformMappingDto',
        };
}
# @return AITransformMappingDto
#
sub create_transformer_mappings {
    my ($self, %args) = @_;

    # verify the required parameter 'create_ai_transformer_mapping_options' is set
    unless (exists $args{'create_ai_transformer_mapping_options'}) {
      croak("Missing the required parameter 'create_ai_transformer_mapping_options' when calling create_transformer_mappings");
    }

    # parse inputs
    my $_resource_path = '/ai/transformer/mappings';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'create_ai_transformer_mapping_options'}) {
        $_body_data = $args{'create_ai_transformer_mapping_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AITransformMappingDto', $response);
    return $_response_object;
}

#
# delete_all_transformer_mappings
#
# Delete all transformer mapping
# 
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'delete_all_transformer_mappings' } = { 
        summary => 'Delete all transformer mapping',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub delete_all_transformer_mappings {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/ai/transformer/mappings';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# delete_transformer
#
# Delete a transformer
# 
# @param string $id  (required)
{
    my $params = {
    'id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_transformer' } = { 
        summary => 'Delete a transformer',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub delete_transformer {
    my ($self, %args) = @_;

    # verify the required parameter 'id' is set
    unless (exists $args{'id'}) {
      croak("Missing the required parameter 'id' when calling delete_transformer");
    }

    # parse inputs
    my $_resource_path = '/ai/transformer/{id}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'id'}) {
        my $_base_variable = "{" . "id" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# delete_transformer_mapping
#
# Delete transformer mapping
# 
# @param string $id ID of transform mapping (required)
{
    my $params = {
    'id' => {
        data_type => 'string',
        description => 'ID of transform mapping',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'delete_transformer_mapping' } = { 
        summary => 'Delete transformer mapping',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub delete_transformer_mapping {
    my ($self, %args) = @_;

    # verify the required parameter 'id' is set
    unless (exists $args{'id'}) {
      croak("Missing the required parameter 'id' when calling delete_transformer_mapping");
    }

    # parse inputs
    my $_resource_path = '/ai/transformer/mappings/{id}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'id'}) {
        my $_base_variable = "{" . "id" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# delete_transformers
#
# Delete all transformers
# 
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'delete_transformers' } = { 
        summary => 'Delete all transformers',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub delete_transformers {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/ai/transformer';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# generate_structured_content_from_attachment
#
# Generate structured content for an attachment
# 
# @param GenerateStructuredContentAttachmentOptions $generate_structured_content_attachment_options  (required)
{
    my $params = {
    'generate_structured_content_attachment_options' => {
        data_type => 'GenerateStructuredContentAttachmentOptions',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'generate_structured_content_from_attachment' } = { 
        summary => 'Generate structured content for an attachment',
        params => $params,
        returns => 'StructuredContentResultDto',
        };
}
# @return StructuredContentResultDto
#
sub generate_structured_content_from_attachment {
    my ($self, %args) = @_;

    # verify the required parameter 'generate_structured_content_attachment_options' is set
    unless (exists $args{'generate_structured_content_attachment_options'}) {
      croak("Missing the required parameter 'generate_structured_content_attachment_options' when calling generate_structured_content_from_attachment");
    }

    # parse inputs
    my $_resource_path = '/ai/structured-content/attachment';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'generate_structured_content_attachment_options'}) {
        $_body_data = $args{'generate_structured_content_attachment_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('StructuredContentResultDto', $response);
    return $_response_object;
}

#
# generate_structured_content_from_email
#
# Generate structured content for an email
# 
# @param GenerateStructuredContentEmailOptions $generate_structured_content_email_options  (required)
{
    my $params = {
    'generate_structured_content_email_options' => {
        data_type => 'GenerateStructuredContentEmailOptions',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'generate_structured_content_from_email' } = { 
        summary => 'Generate structured content for an email',
        params => $params,
        returns => 'StructuredContentResultDto',
        };
}
# @return StructuredContentResultDto
#
sub generate_structured_content_from_email {
    my ($self, %args) = @_;

    # verify the required parameter 'generate_structured_content_email_options' is set
    unless (exists $args{'generate_structured_content_email_options'}) {
      croak("Missing the required parameter 'generate_structured_content_email_options' when calling generate_structured_content_from_email");
    }

    # parse inputs
    my $_resource_path = '/ai/structured-content/email';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'generate_structured_content_email_options'}) {
        $_body_data = $args{'generate_structured_content_email_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('StructuredContentResultDto', $response);
    return $_response_object;
}

#
# generate_structured_content_from_sms
#
# Generate structured content for a TXT message
# 
# @param GenerateStructuredContentSmsOptions $generate_structured_content_sms_options  (required)
{
    my $params = {
    'generate_structured_content_sms_options' => {
        data_type => 'GenerateStructuredContentSmsOptions',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'generate_structured_content_from_sms' } = { 
        summary => 'Generate structured content for a TXT message',
        params => $params,
        returns => 'StructuredContentResultDto',
        };
}
# @return StructuredContentResultDto
#
sub generate_structured_content_from_sms {
    my ($self, %args) = @_;

    # verify the required parameter 'generate_structured_content_sms_options' is set
    unless (exists $args{'generate_structured_content_sms_options'}) {
      croak("Missing the required parameter 'generate_structured_content_sms_options' when calling generate_structured_content_from_sms");
    }

    # parse inputs
    my $_resource_path = '/ai/structured-content/sms';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'generate_structured_content_sms_options'}) {
        $_body_data = $args{'generate_structured_content_sms_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('StructuredContentResultDto', $response);
    return $_response_object;
}

#
# get_transformer
#
# Get a transformer
# 
# @param string $id  (required)
{
    my $params = {
    'id' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_transformer' } = { 
        summary => 'Get a transformer',
        params => $params,
        returns => 'AITransformDto',
        };
}
# @return AITransformDto
#
sub get_transformer {
    my ($self, %args) = @_;

    # verify the required parameter 'id' is set
    unless (exists $args{'id'}) {
      croak("Missing the required parameter 'id' when calling get_transformer");
    }

    # parse inputs
    my $_resource_path = '/ai/transformer/{id}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'id'}) {
        my $_base_variable = "{" . "id" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AITransformDto', $response);
    return $_response_object;
}

#
# get_transformer_mapping
#
# Get transformer mapping
# 
# @param string $id ID of transform mapping (required)
{
    my $params = {
    'id' => {
        data_type => 'string',
        description => 'ID of transform mapping',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_transformer_mapping' } = { 
        summary => 'Get transformer mapping',
        params => $params,
        returns => 'AITransformMappingDto',
        };
}
# @return AITransformMappingDto
#
sub get_transformer_mapping {
    my ($self, %args) = @_;

    # verify the required parameter 'id' is set
    unless (exists $args{'id'}) {
      croak("Missing the required parameter 'id' when calling get_transformer_mapping");
    }

    # parse inputs
    my $_resource_path = '/ai/transformer/mappings/{id}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'id'}) {
        my $_base_variable = "{" . "id" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AITransformMappingDto', $response);
    return $_response_object;
}

#
# get_transformer_mappings
#
# Get transformer mappings
# 
# @param string $ai_transform_id  (optional)
# @param string $entity_id  (optional)
# @param string $entity_type  (optional)
# @param int $page  (optional, default to 0)
# @param int $size Optional page size. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)
# @param string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
{
    my $params = {
    'ai_transform_id' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'entity_id' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'entity_type' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'page' => {
        data_type => 'int',
        description => '',
        required => '0',
    },
    'size' => {
        data_type => 'int',
        description => 'Optional page size. Maximum size is 100. Use page index and sort to page through larger results',
        required => '0',
    },
    'sort' => {
        data_type => 'string',
        description => 'Optional createdAt sort direction ASC or DESC',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_transformer_mappings' } = { 
        summary => 'Get transformer mappings',
        params => $params,
        returns => 'PageAITransformMappingProjection',
        };
}
# @return PageAITransformMappingProjection
#
sub get_transformer_mappings {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/ai/transformer/mappings';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'ai_transform_id'}) {
        $query_params->{'aiTransformId'} = $self->{api_client}->to_query_value($args{'ai_transform_id'});
    }

    # query params
    if ( exists $args{'entity_id'}) {
        $query_params->{'entityId'} = $self->{api_client}->to_query_value($args{'entity_id'});
    }

    # query params
    if ( exists $args{'entity_type'}) {
        $query_params->{'entityType'} = $self->{api_client}->to_query_value($args{'entity_type'});
    }

    # query params
    if ( exists $args{'page'}) {
        $query_params->{'page'} = $self->{api_client}->to_query_value($args{'page'});
    }

    # query params
    if ( exists $args{'size'}) {
        $query_params->{'size'} = $self->{api_client}->to_query_value($args{'size'});
    }

    # query params
    if ( exists $args{'sort'}) {
        $query_params->{'sort'} = $self->{api_client}->to_query_value($args{'sort'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('PageAITransformMappingProjection', $response);
    return $_response_object;
}

#
# get_transformer_result
#
# Get transformer result
# 
# @param string $id ID of transform result (required)
{
    my $params = {
    'id' => {
        data_type => 'string',
        description => 'ID of transform result',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_transformer_result' } = { 
        summary => 'Get transformer result',
        params => $params,
        returns => 'AITransformResultDto',
        };
}
# @return AITransformResultDto
#
sub get_transformer_result {
    my ($self, %args) = @_;

    # verify the required parameter 'id' is set
    unless (exists $args{'id'}) {
      croak("Missing the required parameter 'id' when calling get_transformer_result");
    }

    # parse inputs
    my $_resource_path = '/ai/transformer/results/{id}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'id'}) {
        my $_base_variable = "{" . "id" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'id'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('AITransformResultDto', $response);
    return $_response_object;
}

#
# get_transformer_results
#
# Get transformer results
# 
# @param string $ai_transform_id  (optional)
# @param string $ai_transform_mapping_id  (optional)
# @param string $entity_id  (optional)
# @param string $entity_type  (optional)
# @param int $page  (optional, default to 0)
# @param int $size Optional page size. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)
# @param string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
{
    my $params = {
    'ai_transform_id' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'ai_transform_mapping_id' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'entity_id' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'entity_type' => {
        data_type => 'string',
        description => '',
        required => '0',
    },
    'page' => {
        data_type => 'int',
        description => '',
        required => '0',
    },
    'size' => {
        data_type => 'int',
        description => 'Optional page size. Maximum size is 100. Use page index and sort to page through larger results',
        required => '0',
    },
    'sort' => {
        data_type => 'string',
        description => 'Optional createdAt sort direction ASC or DESC',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_transformer_results' } = { 
        summary => 'Get transformer results',
        params => $params,
        returns => 'PageAITransformResultProjection',
        };
}
# @return PageAITransformResultProjection
#
sub get_transformer_results {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/ai/transformer/results';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'ai_transform_id'}) {
        $query_params->{'aiTransformId'} = $self->{api_client}->to_query_value($args{'ai_transform_id'});
    }

    # query params
    if ( exists $args{'ai_transform_mapping_id'}) {
        $query_params->{'aiTransformMappingId'} = $self->{api_client}->to_query_value($args{'ai_transform_mapping_id'});
    }

    # query params
    if ( exists $args{'entity_id'}) {
        $query_params->{'entityId'} = $self->{api_client}->to_query_value($args{'entity_id'});
    }

    # query params
    if ( exists $args{'entity_type'}) {
        $query_params->{'entityType'} = $self->{api_client}->to_query_value($args{'entity_type'});
    }

    # query params
    if ( exists $args{'page'}) {
        $query_params->{'page'} = $self->{api_client}->to_query_value($args{'page'});
    }

    # query params
    if ( exists $args{'size'}) {
        $query_params->{'size'} = $self->{api_client}->to_query_value($args{'size'});
    }

    # query params
    if ( exists $args{'sort'}) {
        $query_params->{'sort'} = $self->{api_client}->to_query_value($args{'sort'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('PageAITransformResultProjection', $response);
    return $_response_object;
}

#
# get_transformers
#
# List transformers
# 
# @param int $page  (optional, default to 0)
# @param int $size Optional page size in SMS list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)
# @param string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
# @param ARRAY[string] $include Optional list of IDs to include in result (optional)
{
    my $params = {
    'page' => {
        data_type => 'int',
        description => '',
        required => '0',
    },
    'size' => {
        data_type => 'int',
        description => 'Optional page size in SMS list pagination. Maximum size is 100. Use page index and sort to page through larger results',
        required => '0',
    },
    'sort' => {
        data_type => 'string',
        description => 'Optional createdAt sort direction ASC or DESC',
        required => '0',
    },
    'include' => {
        data_type => 'ARRAY[string]',
        description => 'Optional list of IDs to include in result',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'get_transformers' } = { 
        summary => 'List transformers',
        params => $params,
        returns => 'PageAITransformProjection',
        };
}
# @return PageAITransformProjection
#
sub get_transformers {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/ai/transformer';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # query params
    if ( exists $args{'page'}) {
        $query_params->{'page'} = $self->{api_client}->to_query_value($args{'page'});
    }

    # query params
    if ( exists $args{'size'}) {
        $query_params->{'size'} = $self->{api_client}->to_query_value($args{'size'});
    }

    # query params
    if ( exists $args{'sort'}) {
        $query_params->{'sort'} = $self->{api_client}->to_query_value($args{'sort'});
    }

    # query params
    if ( exists $args{'include'}) {
        $query_params->{'include'} = $self->{api_client}->to_query_value($args{'include'});
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('PageAITransformProjection', $response);
    return $_response_object;
}

#
# invoke_transformer
#
# Invoke a transformer
# 
# @param InvokeTransformerOptions $invoke_transformer_options  (required)
{
    my $params = {
    'invoke_transformer_options' => {
        data_type => 'InvokeTransformerOptions',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'invoke_transformer' } = { 
        summary => 'Invoke a transformer',
        params => $params,
        returns => 'ConditionalStructuredContentResult',
        };
}
# @return ConditionalStructuredContentResult
#
sub invoke_transformer {
    my ($self, %args) = @_;

    # verify the required parameter 'invoke_transformer_options' is set
    unless (exists $args{'invoke_transformer_options'}) {
      croak("Missing the required parameter 'invoke_transformer_options' when calling invoke_transformer");
    }

    # parse inputs
    my $_resource_path = '/ai/transformer/invoke';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'invoke_transformer_options'}) {
        $_body_data = $args{'invoke_transformer_options'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ConditionalStructuredContentResult', $response);
    return $_response_object;
}

#
# validate_structured_output_schema
#
# Validate structured content schema
# 
# @param StructuredOutputSchema $structured_output_schema  (required)
{
    my $params = {
    'structured_output_schema' => {
        data_type => 'StructuredOutputSchema',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'validate_structured_output_schema' } = { 
        summary => 'Validate structured content schema',
        params => $params,
        returns => 'StructuredOutputSchemaValidation',
        };
}
# @return StructuredOutputSchemaValidation
#
sub validate_structured_output_schema {
    my ($self, %args) = @_;

    # verify the required parameter 'structured_output_schema' is set
    unless (exists $args{'structured_output_schema'}) {
      croak("Missing the required parameter 'structured_output_schema' when calling validate_structured_output_schema");
    }

    # parse inputs
    my $_resource_path = '/ai/structured-content/validate';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('*/*');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'structured_output_schema'}) {
        $_body_data = $args{'structured_output_schema'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(API_KEY )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('StructuredOutputSchemaValidation', $response);
    return $_response_object;
}

1;
